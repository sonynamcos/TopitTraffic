{
  "permissions": {
    "allow": [
      "Bash(powershell -Command:*)",
      "Bash(python:*)",
      "Bash(cmd /c \"chcp 65001>nul & more\")",
      "Bash(npm install:*)",
      "Bash(curl:*)",
      "Bash(npx vite build)",
      "Bash(dir:*)",
      "Bash(node -e:*)",
      "Bash(netstat:*)",
      "Bash(tasklist:*)",
      "Bash(taskkill:*)",
      "Bash(cmd /c \"cd /d C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\webapp && npx vite build\")",
      "Bash(cmd /c \"cd /d C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\webapp && npx vite build 2>&1\")",
      "Bash(cmd /c \"cd /d C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\webapp && npx.cmd vite build 2>&1\")",
      "Bash(pip install:*)",
      "Bash(chcp:*)",
      "Bash(cmd /c:*)",
      "Bash(\"C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\extract_edges.py\" << 'PYEOF'\nimport json\nimport math\nimport fitz  # PyMuPDF\n\n# ── 1. Load nodes ──────────────────────────────────────────────────\nwith open\\(r'C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\pdf_extracted_nodes.json', 'r', encoding='utf-8'\\) as f:\n    nodes = json.load\\(f\\)\n\nprint\\(f\"Loaded {len\\(nodes\\)} nodes\"\\)\n\nnode_pts = [\\(n['node_cx'], n['node_cy']\\) for n in nodes]\nnode_codes = [n['code'] for n in nodes]\nnode_names = [n['name'] for n in nodes]\n\ndef nearest_node\\(px, py, max_dist=40.0\\):\n    \"\"\"Return \\(index, distance\\) of closest node within max_dist, or \\(None, inf\\).\"\"\"\n    best_i, best_d = None, float\\('inf'\\)\n    for i, \\(nx, ny\\) in enumerate\\(node_pts\\):\n        d = math.hypot\\(px - nx, py - ny\\)\n        if d < best_d:\n            best_i, best_d = i, d\n    if best_d <= max_dist:\n        return best_i, best_d\n    return None, best_d\n\n# ── 2. Open PDF & get drawings ─────────────────────────────────────\ndoc = fitz.open\\(r'C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\복사본 A3size_보령 신호제어기 요도\\(적색점멸용\\)20240710.pdf'\\)\npage = doc[0]\nprint\\(f\"Page size: {page.rect.width:.0f} x {page.rect.height:.0f} pts\"\\)\n\ndrawings = page.get_drawings\\(\\)\nprint\\(f\"Total drawing paths: {len\\(drawings\\)}\"\\)\n\n# ── 3. Extract edges ───────────────────────────────────────────────\nedge_set = set\\(\\)       # \\(min_code, max_code\\) for dedup\nedge_list_raw = []     # for debugging\n\nMAX_DIST = 40.0\n\n# Strategy A: per-path, first point ↔ last point\npath_edges = 0\nfor d in drawings:\n    items = d.get\\('items', []\\)\n    if not items:\n        continue\n\n    # Collect all points from the path\n    points = []\n    for item in items:\n        op = item[0]  # operation type: 'm', 'l', 'c', 'qu', 're', etc.\n        if op == 'l':    # lineto: item is \\('l', Point1, Point2\\)\n            p1 = item[1]\n            p2 = item[2]\n            if not points or \\(points[-1] != \\(p1.x, p1.y\\)\\):\n                points.append\\(\\(p1.x, p1.y\\)\\)\n            points.append\\(\\(p2.x, p2.y\\)\\)\n        elif op == 'm':  # moveto: item is \\('m', x, y\\) -- but let's check actual format\n            # In PyMuPDF, moveto item: \\('m', x, y\\) -- a point\n            # Actually it might be \\('m', Point\\)\n            if len\\(item\\) == 2:\n                pt = item[1]\n                points.append\\(\\(pt.x, pt.y\\)\\)\n            elif len\\(item\\) == 3:\n                points.append\\(\\(item[1], item[2]\\)\\)\n        elif op == 'c':  # curve: \\('c', p1, p2, p3, p4\\)\n            # Start = p1, end = p4\n            p1 = item[1]\n            p4 = item[4] if len\\(item\\) > 4 else item[-1]\n            if not points or \\(points[-1] != \\(p1.x, p1.y\\)\\):\n                points.append\\(\\(p1.x, p1.y\\)\\)\n            points.append\\(\\(p4.x, p4.y\\)\\)\n\n    if len\\(points\\) < 2:\n        continue\n\n    first = points[0]\n    last = points[-1]\n\n    ni1, d1 = nearest_node\\(first[0], first[1], MAX_DIST\\)\n    ni2, d2 = nearest_node\\(last[0], last[1], MAX_DIST\\)\n\n    if ni1 is not None and ni2 is not None and ni1 != ni2:\n        a, b = node_codes[ni1], node_codes[ni2]\n        key = tuple\\(sorted\\([a, b]\\)\\)\n        if key not in edge_set:\n            edge_set.add\\(key\\)\n            path_edges += 1\n\nprint\\(f\"\\\\nStrategy A \\(first↔last per path\\): {path_edges} unique edges\"\\)\n\n# Strategy B: per individual line segment within each path\nseg_edges = 0\nfor d in drawings:\n    items = d.get\\('items', []\\)\n    for item in items:\n        op = item[0]\n        if op == 'l':\n            p1, p2 = item[1], item[2]\n            ni1, d1 = nearest_node\\(p1.x, p1.y, MAX_DIST\\)\n            ni2, d2 = nearest_node\\(p2.x, p2.y, MAX_DIST\\)\n            if ni1 is not None and ni2 is not None and ni1 != ni2:\n                a, b = node_codes[ni1], node_codes[ni2]\n                key = tuple\\(sorted\\([a, b]\\)\\)\n                if key not in edge_set:\n                    edge_set.add\\(key\\)\n                    seg_edges += 1\n        elif op == 'c':\n            p1 = item[1]\n            p4 = item[4] if len\\(item\\) > 4 else item[-1]\n            ni1, d1 = nearest_node\\(p1.x, p1.y, MAX_DIST\\)\n            ni2, d2 = nearest_node\\(p4.x, p4.y, MAX_DIST\\)\n            if ni1 is not None and ni2 is not None and ni1 != ni2:\n                a, b = node_codes[ni1], node_codes[ni2]\n                key = tuple\\(sorted\\([a, b]\\)\\)\n                if key not in edge_set:\n                    edge_set.add\\(key\\)\n                    seg_edges += 1\n\nprint\\(f\"Strategy B \\(per segment, additional\\): {seg_edges} unique edges\"\\)\nprint\\(f\"Total unique edges: {len\\(edge_set\\)}\"\\)\n\n# ── 4. Build final edge list with metadata ─────────────────────────\ncode_to_node = {n['code']: n for n in nodes}\n\nedges = []\nfor a, b in sorted\\(edge_set\\):\n    na = code_to_node[a]\n    nb = code_to_node[b]\n    dist = math.hypot\\(na['node_cx'] - nb['node_cx'], na['node_cy'] - nb['node_cy']\\)\n    edges.append\\({\n        \"from_code\": a,\n        \"from_name\": na['name'],\n        \"to_code\": b,\n        \"to_name\": nb['name'],\n        \"distance_pts\": round\\(dist, 1\\)\n    }\\)\n\n# ── 5. Print complete edge list ────────────────────────────────────\nprint\\(f\"\\\\n{'='*80}\"\\)\nprint\\(f\"COMPLETE EDGE LIST \\({len\\(edges\\)} edges\\)\"\\)\nprint\\(f\"{'='*80}\"\\)\nfor i, e in enumerate\\(edges, 1\\):\n    print\\(f\"  {i:3d}. [{e['from_code']}] {e['from_name']:<12s} ↔ [{e['to_code']}] {e['to_name']:<12s}  \\(dist={e['distance_pts']:.1f} pts\\)\"\\)\n\n# ── 6. Summary stats ───────────────────────────────────────────────\ndists = [e['distance_pts'] for e in edges]\nprint\\(f\"\\\\n{'='*80}\"\\)\nprint\\(f\"SUMMARY\"\\)\nprint\\(f\"{'='*80}\"\\)\nprint\\(f\"  Total edges:    {len\\(edges\\)}\"\\)\nprint\\(f\"  Total nodes:    {len\\(nodes\\)}\"\\)\nprint\\(f\"  Avg degree:     {2*len\\(edges\\)/len\\(nodes\\):.2f}\"\\)\nprint\\(f\"  Distance stats: min={min\\(dists\\):.1f}, max={max\\(dists\\):.1f}, avg={sum\\(dists\\)/len\\(dists\\):.1f} pts\"\\)\n\n# Count node degrees\nfrom collections import Counter\ndeg = Counter\\(\\)\nfor e in edges:\n    deg[e['from_code']] += 1\n    deg[e['to_code']] += 1\n\nisolated = [n['code'] for n in nodes if deg[n['code']] == 0]\nprint\\(f\"  Isolated nodes \\(degree 0\\): {len\\(isolated\\)}\"\\)\nif isolated:\n    for code in isolated:\n        n = code_to_node[code]\n        print\\(f\"    [{code}] {n['name']}\"\\)\n\nmax_deg = max\\(deg.values\\(\\)\\) if deg else 0\nmax_deg_nodes = [c for c, d in deg.items\\(\\) if d == max_deg]\nprint\\(f\"  Max degree:     {max_deg} \\(nodes: {max_deg_nodes}\\)\"\\)\n\n# ── 7. SAVE JSON ───────────────────────────────────────────────────\noutput_path = r'C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\pdf_extracted_edges.json'\nwith open\\(output_path, 'w', encoding='utf-8'\\) as f:\n    json.dump\\(edges, f, ensure_ascii=False, indent=2\\)\n\nprint\\(f\"\\\\nSaved {len\\(edges\\)} edges to: {output_path}\"\\)\n\ndoc.close\\(\\)\nPYEOF)",
      "Bash(\"C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\debug_drawings.py\" << 'PYEOF'\nimport fitz\nimport json\nfrom collections import Counter\n\ndoc = fitz.open\\(r'C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\복사본 A3size_보령 신호제어기 요도\\(적색점멸용\\)20240710.pdf'\\)\npage = doc[0]\ndrawings = page.get_drawings\\(\\)\n\n# Analyze item types across all drawings\nop_counts = Counter\\(\\)\nitem_lengths = Counter\\(\\)\nfor d in drawings:\n    items = d.get\\('items', []\\)\n    for item in items:\n        op_counts[item[0]] += 1\n        item_lengths[\\(item[0], len\\(item\\)\\)] += 1\n\nprint\\(\"Operation type counts:\"\\)\nfor op, cnt in op_counts.most_common\\(\\):\n    print\\(f\"  {op}: {cnt}\"\\)\n\nprint\\(\"\\\\n\\(op, item_length\\) counts:\"\\)\nfor \\(op, length\\), cnt in item_lengths.most_common\\(\\):\n    print\\(f\"  \\({op}, len={length}\\): {cnt}\"\\)\n\n# Check for 're' \\(rectangle\\) items that might represent connections\nprint\\(\"\\\\nDrawing keys sample \\(first 5\\):\"\\)\nfor d in drawings[:5]:\n    print\\(f\"  keys: {list\\(d.keys\\(\\)\\)}\"\\)\n    items = d.get\\('items', []\\)\n    for item in items[:3]:\n        print\\(f\"    item[0]={item[0]}, len={len\\(item\\)}, types={[type\\(x\\).__name__ for x in item]}\"\\)\n\n# Check path properties - color, width, fill\nprint\\(\"\\\\nPath property analysis:\"\\)\ncolors = Counter\\(\\)\nwidths = Counter\\(\\)\nfor d in drawings:\n    c = d.get\\('color'\\)\n    w = d.get\\('width'\\)\n    colors[str\\(c\\)] += 1\n    widths[w] += 1\n\nprint\\(\"Colors \\(top 10\\):\"\\)\nfor c, cnt in colors.most_common\\(10\\):\n    print\\(f\"  {c}: {cnt}\"\\)\nprint\\(\"Widths \\(top 10\\):\"\\)\nfor w, cnt in widths.most_common\\(10\\):\n    print\\(f\"  {w}: {cnt}\"\\)\n\n# Look at fill vs stroke\nfill_counts = Counter\\(\\)\nfor d in drawings:\n    has_fill = d.get\\('fill'\\) is not None\n    has_color = d.get\\('color'\\) is not None\n    fill_counts[\\(has_fill, has_color\\)] += 1\nprint\\(\"\\\\n\\(has_fill, has_stroke\\) counts:\"\\)\nfor k, cnt in fill_counts.most_common\\(\\):\n    print\\(f\"  fill={k[0]}, stroke={k[1]}: {cnt}\"\\)\n\ndoc.close\\(\\)\nPYEOF)",
      "Bash(\"C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\debug_drawings2.py\" << 'PYEOF'\nimport fitz\nimport json\nimport math\n\nwith open\\(r'C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\pdf_extracted_nodes.json', 'r', encoding='utf-8'\\) as f:\n    nodes = json.load\\(f\\)\n\nnode_pts = [\\(n['node_cx'], n['node_cy']\\) for n in nodes]\nnode_codes = [n['code'] for n in nodes]\n\ndef nearest_node_info\\(px, py\\):\n    best_i, best_d = None, float\\('inf'\\)\n    for i, \\(nx, ny\\) in enumerate\\(node_pts\\):\n        d = math.hypot\\(px - nx, py - ny\\)\n        if d < best_d:\n            best_i, best_d = i, d\n    return best_i, best_d\n\ndoc = fitz.open\\(r'C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\복사본 A3size_보령 신호제어기 요도\\(적색점멸용\\)20240710.pdf'\\)\npage = doc[0]\ndrawings = page.get_drawings\\(\\)\n\n# Focus on line \\('l'\\) items: look at segments near nodes\n# and also look at curves \\('c'\\) items\nprint\\(\"=== Analysis of 'l' \\(line\\) segments ===\"\\)\nl_near_count = 0\nl_total = 0\nfor d in drawings:\n    for item in d['items']:\n        if item[0] == 'l':\n            l_total += 1\n            p1, p2 = item[1], item[2]\n            _, d1 = nearest_node_info\\(p1.x, p1.y\\)\n            _, d2 = nearest_node_info\\(p2.x, p2.y\\)\n            if d1 < 40 or d2 < 40:\n                l_near_count += 1\n\nprint\\(f\"Total 'l' segments: {l_total}\"\\)\nprint\\(f\"Segments with at least one end near a node \\(<40pt\\): {l_near_count}\"\\)\n\nprint\\(\"\\\\n=== Analysis of 'c' \\(curve\\) segments ===\"\\)\nc_near_count = 0\nc_total = 0\nfor d in drawings:\n    for item in d['items']:\n        if item[0] == 'c':\n            c_total += 1\n            p1, p4 = item[1], item[4]\n            _, d1 = nearest_node_info\\(p1.x, p1.y\\)\n            _, d2 = nearest_node_info\\(p4.x, p4.y\\)\n            if d1 < 40 or d2 < 40:\n                c_near_count += 1\n\nprint\\(f\"Total 'c' curves: {c_total}\"\\)\nprint\\(f\"Curves with at least one end near a node \\(<40pt\\): {c_near_count}\"\\)\n\n# Look at multi-segment paths that start/end near nodes\n# but travel through intermediate waypoints\nprint\\(\"\\\\n=== Multi-segment path analysis ===\"\\)\nfor d in drawings:\n    items = d['items']\n    # Only look at paths with multiple l/c items\n    lc_items = [it for it in items if it[0] in \\('l', 'c'\\)]\n    if len\\(lc_items\\) < 2:\n        continue\n    \n    # Collect all unique points along the path\n    all_points = []\n    for it in lc_items:\n        if it[0] == 'l':\n            all_points.append\\(\\(it[1].x, it[1].y\\)\\)\n            all_points.append\\(\\(it[2].x, it[2].y\\)\\)\n        elif it[0] == 'c':\n            all_points.append\\(\\(it[1].x, it[1].y\\)\\)\n            all_points.append\\(\\(it[4].x, it[4].y\\)\\)\n    \n    # Check which points are near nodes\n    near_nodes = []\n    for px, py in all_points:\n        ni, nd = nearest_node_info\\(px, py\\)\n        if nd < 40:\n            near_nodes.append\\(\\(ni, nd, px, py\\)\\)\n    \n    # Deduplicate by node index\n    seen = set\\(\\)\n    unique_near = []\n    for ni, nd, px, py in near_nodes:\n        if ni not in seen:\n            seen.add\\(ni\\)\n            unique_near.append\\(\\(ni, nd, px, py\\)\\)\n    \n    if len\\(unique_near\\) >= 2:\n        color = d.get\\('color'\\)\n        width = d.get\\('width'\\)\n        print\\(f\"\\\\n  Path with {len\\(lc_items\\)} segments, color={color}, width={width}\"\\)\n        print\\(f\"  Near nodes \\({len\\(unique_near\\)}\\):\"\\)\n        for ni, nd, px, py in unique_near:\n            print\\(f\"    [{node_codes[ni]}] {nodes[ni]['name']} \\(dist={nd:.1f}\\)\"\\)\n\n# Also check: paths with color that is the dominant line color\n# The main line color seems to be \\(0.29, 0.49, 0.73\\) - bluish\nprint\\(\"\\\\n\\\\n=== Checking ALL points in blue-ish paths ===\"\\)\nblue_paths = [d for d in drawings if d.get\\('color'\\) and \n              abs\\(d['color'][0] - 0.29\\) < 0.05 and abs\\(d['color'][1] - 0.49\\) < 0.05]\nprint\\(f\"Blue paths: {len\\(blue_paths\\)}\"\\)\n\n# Also check orange paths \norange_paths = [d for d in drawings if d.get\\('color'\\) and \n                abs\\(d['color'][0] - 0.89\\) < 0.05 and abs\\(d['color'][1] - 0.42\\) < 0.05]\nprint\\(f\"Orange paths: {len\\(orange_paths\\)}\"\\)\n\n# Green paths\ngreen_paths = [d for d in drawings if d.get\\('color'\\) and \n               abs\\(d['color'][1] - 0.69\\) < 0.05 and abs\\(d['color'][2] - 0.31\\) < 0.05]\nprint\\(f\"Green paths: {len\\(green_paths\\)}\"\\)\n\ndoc.close\\(\\)\nPYEOF)",
      "Bash(\"C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\debug_isolated.py\" << 'PYEOF'\nimport fitz\nimport json\nimport math\n\nwith open\\(r'C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\pdf_extracted_nodes.json', 'r', encoding='utf-8'\\) as f:\n    nodes = json.load\\(f\\)\n\nnode_pts = [\\(n['node_cx'], n['node_cy']\\) for n in nodes]\nnode_codes = [n['code'] for n in nodes]\n\n# Isolated nodes from previous run\nisolated_codes = ['002','003','004','005','007','009','010','011','023',\n                  '041','042','043','046','048','049','055','056','057',\n                  '063','064','066','090','106','108','118','124','129',\n                  '132','135','137','140','141','142','147','148','149',\n                  '150','154','155','161','165','166','171','173','176']\n\ncode_to_idx = {n['code']: i for i, n in enumerate\\(nodes\\)}\n\ndoc = fitz.open\\(r'C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\복사본 A3size_보령 신호제어기 요도\\(적색점멸용\\)20240710.pdf'\\)\npage = doc[0]\ndrawings = page.get_drawings\\(\\)\n\n# For each isolated node, find the closest line endpoint in any drawing\nfor code in isolated_codes:\n    idx = code_to_idx[code]\n    nx, ny = node_pts[idx]\n    \n    best_dist = float\\('inf'\\)\n    best_info = None\n    \n    for d_i, d in enumerate\\(drawings\\):\n        for item in d['items']:\n            pts = []\n            if item[0] == 'l':\n                pts = [\\(item[1].x, item[1].y\\), \\(item[2].x, item[2].y\\)]\n            elif item[0] == 'c':\n                pts = [\\(item[1].x, item[1].y\\), \\(item[4].x, item[4].y\\)]\n            elif item[0] == 're':\n                # Rectangle: item[1] is Rect\n                continue\n            \n            for px, py in pts:\n                d_val = math.hypot\\(px - nx, py - ny\\)\n                if d_val < best_dist:\n                    best_dist = d_val\n                    best_info = \\(d_i, item[0], px, py, d.get\\('color'\\), d.get\\('width'\\)\\)\n    \n    n = nodes[idx]\n    if best_dist < 60:\n        print\\(f\"[{code}] {n['name']:<14s} node=\\({nx:.1f},{ny:.1f}\\)  closest_pt=\\({best_info[2]:.1f},{best_info[3]:.1f}\\)  dist={best_dist:.1f}  op={best_info[1]}  color={best_info[4]}  width={best_info[5]}\"\\)\n    else:\n        print\\(f\"[{code}] {n['name']:<14s} node=\\({nx:.1f},{ny:.1f}\\)  FARAWAY  closest_dist={best_dist:.1f}\"\\)\n\ndoc.close\\(\\)\nPYEOF)",
      "Bash(\"C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\extract_edges_v2.py\" << 'PYEOF'\nimport json\nimport math\nimport fitz\n\n# ── 1. Load nodes ──────────────────────────────────────────────────\nwith open\\(r'C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\pdf_extracted_nodes.json', 'r', encoding='utf-8'\\) as f:\n    nodes = json.load\\(f\\)\n\nprint\\(f\"Loaded {len\\(nodes\\)} nodes\"\\)\n\nnode_pts = [\\(n['node_cx'], n['node_cy']\\) for n in nodes]\nnode_codes = [n['code'] for n in nodes]\nnode_names = [n['name'] for n in nodes]\ncode_to_node = {n['code']: n for n in nodes}\ncode_to_idx = {n['code']: i for i, n in enumerate\\(nodes\\)}\n\ndef nearest_node\\(px, py, max_dist=40.0\\):\n    \"\"\"Return \\(index, distance\\) of closest node within max_dist, or \\(None, inf\\).\"\"\"\n    best_i, best_d = None, float\\('inf'\\)\n    for i, \\(nx, ny\\) in enumerate\\(node_pts\\):\n        d = math.hypot\\(px - nx, py - ny\\)\n        if d < best_d:\n            best_i, best_d = i, d\n    if best_d <= max_dist:\n        return best_i, best_d\n    return None, best_d\n\n# ── 2. Open PDF & get drawings ─────────────────────────────────────\ndoc = fitz.open\\(r'C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\복사본 A3size_보령 신호제어기 요도\\(적색점멸용\\)20240710.pdf'\\)\npage = doc[0]\nprint\\(f\"Page size: {page.rect.width:.0f} x {page.rect.height:.0f} pts\"\\)\n\ndrawings = page.get_drawings\\(\\)\nprint\\(f\"Total drawing paths: {len\\(drawings\\)}\"\\)\n\n# ── 3. Build comprehensive edge set ────────────────────────────────\nedge_set = set\\(\\)\nMAX_DIST = 40.0\n\ndef add_edge\\(ni1, ni2\\):\n    \"\"\"Add edge to set if both nodes are valid and different.\"\"\"\n    if ni1 is not None and ni2 is not None and ni1 != ni2:\n        a, b = node_codes[ni1], node_codes[ni2]\n        edge_set.add\\(tuple\\(sorted\\([a, b]\\)\\)\\)\n\n# ── Strategy A: For each drawing path, collect ALL endpoint/waypoints ──\n# and find ALL pairs of adjacent-near-node points\nfor d in drawings:\n    items = d.get\\('items', []\\)\n    if not items:\n        continue\n    \n    # Skip pure rectangles that are likely node markers \\(filled, no stroke\\)\n    # Also skip items that are clearly fills\n    \n    # Collect ordered list of \\(x, y\\) endpoints from path segments\n    path_points = []\n    for item in items:\n        op = item[0]\n        if op == 'l':\n            p1, p2 = item[1], item[2]\n            path_points.append\\(\\(p1.x, p1.y\\)\\)\n            path_points.append\\(\\(p2.x, p2.y\\)\\)\n        elif op == 'c':\n            p1, p4 = item[1], item[4]\n            path_points.append\\(\\(p1.x, p1.y\\)\\)\n            path_points.append\\(\\(p4.x, p4.y\\)\\)\n        elif op == 're':\n            # Rectangle - skip as it's typically a node marker\n            continue\n    \n    if len\\(path_points\\) < 2:\n        continue\n    \n    # Remove consecutive duplicate points\n    deduped = [path_points[0]]\n    for pt in path_points[1:]:\n        if abs\\(pt[0] - deduped[-1][0]\\) > 0.1 or abs\\(pt[1] - deduped[-1][1]\\) > 0.1:\n            deduped.append\\(pt\\)\n    path_points = deduped\n    \n    # Method 1: first point <-> last point\n    first = path_points[0]\n    last = path_points[-1]\n    ni1, d1 = nearest_node\\(first[0], first[1], MAX_DIST\\)\n    ni2, d2 = nearest_node\\(last[0], last[1], MAX_DIST\\)\n    add_edge\\(ni1, ni2\\)\n    \n    # Method 2: For each point along the path, find its nearest node.\n    # Then look for transitions \\(where the nearest node changes\\) -> that's an edge.\n    prev_node = None\n    for pt in path_points:\n        ni, nd = nearest_node\\(pt[0], pt[1], MAX_DIST\\)\n        if ni is not None and ni != prev_node:\n            if prev_node is not None:\n                add_edge\\(prev_node, ni\\)\n            prev_node = ni\n\n# ── Strategy B: Individual line segments ──\nfor d in drawings:\n    items = d.get\\('items', []\\)\n    for item in items:\n        op = item[0]\n        if op == 'l':\n            p1, p2 = item[1], item[2]\n            ni1, d1 = nearest_node\\(p1.x, p1.y, MAX_DIST\\)\n            ni2, d2 = nearest_node\\(p2.x, p2.y, MAX_DIST\\)\n            add_edge\\(ni1, ni2\\)\n        elif op == 'c':\n            p1, p4 = item[1], item[4]\n            ni1, d1 = nearest_node\\(p1.x, p1.y, MAX_DIST\\)\n            ni2, d2 = nearest_node\\(p4.x, p4.y, MAX_DIST\\)\n            add_edge\\(ni1, ni2\\)\n\nprint\\(f\"\\\\nAfter Strategy A+B: {len\\(edge_set\\)} unique edges\"\\)\n\n# ── Strategy C: Chain-based approach for long vertical/horizontal corridors ──\n# Some corridors have a single long line with endpoints connecting distant nodes.\n# The line passes near several intermediate nodes.\n# For these, we need to project each node onto the line segment and check proximity.\n\ndef point_to_segment_dist\\(px, py, x1, y1, x2, y2\\):\n    \"\"\"Distance from point \\(px,py\\) to the nearest point on segment \\(x1,y1\\)-\\(x2,y2\\).\"\"\"\n    dx, dy = x2 - x1, y2 - y1\n    seg_len_sq = dx*dx + dy*dy\n    if seg_len_sq < 1e-10:\n        return math.hypot\\(px - x1, py - y1\\)\n    t = max\\(0, min\\(1, \\(\\(px - x1\\) * dx + \\(py - y1\\) * dy\\) / seg_len_sq\\)\\)\n    proj_x = x1 + t * dx\n    proj_y = y1 + t * dy\n    return math.hypot\\(px - proj_x, py - proj_y\\)\n\n# For each line segment, find ALL nodes within proximity \\(not just endpoints\\),\n# then connect consecutive nodes along the segment direction.\nPROX_DIST = 15.0  # nodes within 15pt of the line\n\nchain_edges_added = 0\nfor d in drawings:\n    items = d.get\\('items', []\\)\n    for item in items:\n        if item[0] != 'l':\n            continue\n        p1, p2 = item[1], item[2]\n        x1, y1, x2, y2 = p1.x, p1.y, p2.x, p2.y\n        seg_len = math.hypot\\(x2 - x1, y2 - y1\\)\n        \n        if seg_len < 5:  # skip tiny segments\n            continue\n        \n        # Find all nodes close to this segment\n        dx, dy = x2 - x1, y2 - y1\n        seg_len_sq = dx*dx + dy*dy\n        \n        close_nodes = []\n        for i, \\(nx, ny\\) in enumerate\\(node_pts\\):\n            d_val = point_to_segment_dist\\(nx, ny, x1, y1, x2, y2\\)\n            if d_val <= PROX_DIST:\n                # Compute parameter t for ordering along segment\n                t = \\(\\(nx - x1\\) * dx + \\(ny - y1\\) * dy\\) / seg_len_sq\n                close_nodes.append\\(\\(t, i\\)\\)\n        \n        if len\\(close_nodes\\) < 2:\n            continue\n        \n        # Sort by t \\(position along segment\\)\n        close_nodes.sort\\(\\)\n        \n        # Connect consecutive nodes along the segment\n        for j in range\\(len\\(close_nodes\\) - 1\\):\n            ni1 = close_nodes[j][1]\n            ni2 = close_nodes[j+1][1]\n            key = tuple\\(sorted\\([node_codes[ni1], node_codes[ni2]]\\)\\)\n            if key not in edge_set:\n                edge_set.add\\(key\\)\n                chain_edges_added += 1\n\nprint\\(f\"Strategy C \\(chain projection\\): +{chain_edges_added} edges\"\\)\nprint\\(f\"Total after C: {len\\(edge_set\\)} unique edges\"\\)\n\n# ── Strategy D: For curves, also do chain projection ──\ncurve_chain_added = 0\nfor d in drawings:\n    items = d.get\\('items', []\\)\n    for item in items:\n        if item[0] != 'c':\n            continue\n        # For curves, approximate with start-end line\n        p1, p4 = item[1], item[4]\n        x1, y1, x2, y2 = p1.x, p1.y, p4.x, p4.y\n        seg_len = math.hypot\\(x2 - x1, y2 - y1\\)\n        if seg_len < 5:\n            continue\n        \n        dx, dy = x2 - x1, y2 - y1\n        seg_len_sq = dx*dx + dy*dy\n        \n        close_nodes = []\n        for i, \\(nx, ny\\) in enumerate\\(node_pts\\):\n            d_val = point_to_segment_dist\\(nx, ny, x1, y1, x2, y2\\)\n            if d_val <= PROX_DIST:\n                t = \\(\\(nx - x1\\) * dx + \\(ny - y1\\) * dy\\) / seg_len_sq\n                close_nodes.append\\(\\(t, i\\)\\)\n        \n        if len\\(close_nodes\\) < 2:\n            continue\n        \n        close_nodes.sort\\(\\)\n        for j in range\\(len\\(close_nodes\\) - 1\\):\n            ni1 = close_nodes[j][1]\n            ni2 = close_nodes[j+1][1]\n            key = tuple\\(sorted\\([node_codes[ni1], node_codes[ni2]]\\)\\)\n            if key not in edge_set:\n                edge_set.add\\(key\\)\n                curve_chain_added += 1\n\nprint\\(f\"Strategy D \\(curve chain\\): +{curve_chain_added} edges\"\\)\nprint\\(f\"Total after D: {len\\(edge_set\\)} unique edges\"\\)\n\n# ── 4. Build final edge list with metadata ─────────────────────────\nedges = []\nfor a, b in sorted\\(edge_set\\):\n    na = code_to_node[a]\n    nb = code_to_node[b]\n    dist = math.hypot\\(na['node_cx'] - nb['node_cx'], na['node_cy'] - nb['node_cy']\\)\n    edges.append\\({\n        \"from_code\": a,\n        \"from_name\": na['name'],\n        \"to_code\": b,\n        \"to_name\": nb['name'],\n        \"distance_pts\": round\\(dist, 1\\)\n    }\\)\n\n# ── 5. Print complete edge list ────────────────────────────────────\nprint\\(f\"\\\\n{'='*80}\"\\)\nprint\\(f\"COMPLETE EDGE LIST \\({len\\(edges\\)} edges\\)\"\\)\nprint\\(f\"{'='*80}\"\\)\nfor i, e in enumerate\\(edges, 1\\):\n    print\\(f\"  {i:3d}. [{e['from_code']}] {e['from_name']:<16s} <-> [{e['to_code']}] {e['to_name']:<16s}  \\(dist={e['distance_pts']:.1f} pts\\)\"\\)\n\n# ── 6. Summary stats ───────────────────────────────────────────────\nfrom collections import Counter\n\ndists = [e['distance_pts'] for e in edges]\ndeg = Counter\\(\\)\nfor e in edges:\n    deg[e['from_code']] += 1\n    deg[e['to_code']] += 1\n\nisolated = [n['code'] for n in nodes if deg[n['code']] == 0]\n\nprint\\(f\"\\\\n{'='*80}\"\\)\nprint\\(f\"SUMMARY\"\\)\nprint\\(f\"{'='*80}\"\\)\nprint\\(f\"  Total edges:    {len\\(edges\\)}\"\\)\nprint\\(f\"  Total nodes:    {len\\(nodes\\)}\"\\)\nprint\\(f\"  Connected nodes:{len\\(nodes\\) - len\\(isolated\\)}\"\\)\nprint\\(f\"  Isolated nodes: {len\\(isolated\\)}\"\\)\nprint\\(f\"  Avg degree:     {2*len\\(edges\\)/len\\(nodes\\):.2f}\"\\)\nprint\\(f\"  Distance stats: min={min\\(dists\\):.1f}, max={max\\(dists\\):.1f}, avg={sum\\(dists\\)/len\\(dists\\):.1f} pts\"\\)\n\nif isolated:\n    print\\(f\"\\\\n  Isolated nodes \\({len\\(isolated\\)}\\):\"\\)\n    for code in isolated:\n        n = code_to_node[code]\n        print\\(f\"    [{code}] {n['name']}\"\\)\n\nmax_deg = max\\(deg.values\\(\\)\\) if deg else 0\nmax_deg_nodes = [\\(c, d\\) for c, d in deg.most_common\\(10\\)]\nprint\\(f\"\\\\n  Top-10 highest degree nodes:\"\\)\nfor c, d in max_deg_nodes:\n    print\\(f\"    [{c}] {code_to_node[c]['name']}: degree {d}\"\\)\n\n# Degree distribution\ndeg_dist = Counter\\(deg.values\\(\\)\\)\nprint\\(f\"\\\\n  Degree distribution:\"\\)\nfor d_val in sorted\\(deg_dist.keys\\(\\)\\):\n    print\\(f\"    degree {d_val}: {deg_dist[d_val]} nodes\"\\)\n\n# ── 7. SAVE JSON ───────────────────────────────────────────────────\noutput_path = r'C:\\\\JJUN_DEV\\\\TopIt-Traffic-DB\\\\pdf_extracted_edges.json'\nwith open\\(output_path, 'w', encoding='utf-8'\\) as f:\n    json.dump\\(edges, f, ensure_ascii=False, indent=2\\)\n\nprint\\(f\"\\\\n*** Saved {len\\(edges\\)} edges to: {output_path} ***\"\\)\n\ndoc.close\\(\\)\nPYEOF)",
      "Bash(python3:*)",
      "Bash(where:*)",
      "Bash(node:*)",
      "Bash(findstr:*)"
    ]
  }
}
