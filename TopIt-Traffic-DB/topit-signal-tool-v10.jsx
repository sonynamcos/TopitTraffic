import { useState, useCallback, useRef, useEffect, useMemo } from "react";

// ── Tauri 저장 다이얼로그 (Tauri 환경에서만 동작) ──
const isTauri = typeof window !== "undefined" && !!window.__TAURI_INTERNALS__;
let tauriSave, tauriWriteFile;
if (isTauri) {
  import("@tauri-apps/plugin-dialog").then(m => { tauriSave = m.save; });
  import("@tauri-apps/plugin-fs").then(m => { tauriWriteFile = m.writeFile; });
}
async function saveFileWithDialog(data, defaultName, filters) {
  if (isTauri && tauriSave && tauriWriteFile) {
    const path = await tauriSave({ title: "파일 저장", defaultPath: defaultName, filters });
    if (!path) return null;
    const bytes = data instanceof Uint8Array ? data : new Uint8Array(await data.arrayBuffer());
    await tauriWriteFile(path, bytes);
    return path;
  }
  // 브라우저 폴백
  const blob = data instanceof Blob ? data : new Blob([data], { type: "application/octet-stream" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a"); a.href = url; a.download = defaultName;
  document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
  return defaultName;
}
/* JSZip loaded dynamically from CDN for template-based Excel export */

const TMPL_B64 = "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";

const DAT = {
  FILE_SIZE: 0x39c0, TIMEPLAN_BASE: 0x0000, ENTRY_SIZE: 20, ENTRIES_PER_PLAN: 8, PLAN_SIZE: 160,
  LSU_ACTIVE_FLAGS: 0x0cda, FLASH_START: 0x0ce4, FLASH_END: 0x0ce6,
  RING_A: 0x0e2a, RING_B: 0x108a, STEP_SIZE: 19, MAX_STEPS: 32,
  LSU_TYPES: 0x2f6a, LSU_CONST: 0x2f7a, MFR_NAME: 0x395a, MFR_DATE: 0x3974,
};

const STEP_CODES = {
  0x00: { label: "적색", short: "R", color: "#dc2626", text: "#fff" },
  0x01: { label: "좌녹", short: "LG", color: "#16a34a", text: "#fff" },
  0x02: { label: "황색", short: "Y", color: "#eab308", text: "#000" },
  0x05: { label: "녹점", short: "GF", color: "#22c55e", text: "#000" },
  0x10: { label: "직녹", short: "G", color: "#22c55e", text: "#000" },
  0x20: { label: "황색", short: "Y", color: "#eab308", text: "#000" },
  0x30: { label: "적점", short: "RF", color: "#dc2626", text: "#fff" },
  0x80: { label: "소등", short: "—", color: "#374151", text: "#9ca3af" },
};
const LSU_TYPES_MAP = { 0x44: "차량4색", 0x33: "차량3색", 0x88: "보행2색" };

const DEFAULT_LSU = [
  { lsu: 1, dir: "북", type: "차량", pos: "top" },
  { lsu: 2, dir: "동", type: "보행", pos: "right-ped" },
  { lsu: 3, dir: "동", type: "차량", pos: "right" },
  { lsu: 4, dir: "남", type: "보행", pos: "bottom-ped" },
  { lsu: 5, dir: "남", type: "차량", pos: "bottom" },
  { lsu: 6, dir: "서", type: "보행", pos: "left-ped" },
  { lsu: 7, dir: "서", type: "차량", pos: "left" },
  { lsu: 8, dir: "북", type: "보행", pos: "top-ped" },
];

// ═══════════════════════════════════════════════════════════════
//  시그널맵 생성 엔진
//  Ring A = 직진(0x10) + 보행(0x01/0x05)
//  Ring B = 좌회전(0x01)
//  보행현시: 5행(4+EOP), 비보행현시: 3행(2+EOP)
// ═══════════════════════════════════════════════════════════════
function generateSignalMap(phases, lsuConfig) {
  const ringA = Array.from({ length: 32 }, () => ({ lsu: new Uint8Array(16), min: 0, max: 0, eop: 0 }));
  const ringB = Array.from({ length: 32 }, () => ({ lsu: new Uint8Array(16), min: 0, max: 0, eop: 0 }));
  let step = 0;

  for (const ph of phases) {
    if (step >= 30) break;
    const lsus = ph.lsus || {};
    const nums = Object.keys(lsus).map(Number).filter((n) => lsus[n] && lsus[n] !== "—");
    if (nums.length === 0) continue;
    const isPed = nums.some((n) => lsus[n] === "보행");

    const setVeh = (s) => { for (const n of nums) { const m = lsus[n]; if (m === "보행") continue; if (m === "직진" || m === "직좌") ringA[s].lsu[n-1] = 0x10; if (m === "좌회전" || m === "직좌") ringB[s].lsu[n-1] = 0x01; }};
    const setPedG = (s) => { for (const n of nums) { if (lsus[n] === "보행") ringA[s].lsu[n-1] = 0x01; }};
    const setPedF = (s) => { for (const n of nums) { if (lsus[n] === "보행") ringA[s].lsu[n-1] = 0x05; }};

    if (isPed) {
      // Row1: MIN=보행대기
      setVeh(step); ringA[step].min = ph.pedWait||1; ringB[step].min = ph.pedWait||1; step++;
      // Row2: MIN=보행녹색만
      if (step<32) { setVeh(step); setPedG(step); ringA[step].min = ph.pedGreen||0; ringB[step].min = ph.pedGreen||0; step++; }
      // Row3: MIN=보행점멸만
      if (step<32) { setVeh(step); setPedF(step); ringA[step].min = ph.pedFlash||0; ringB[step].min = ph.pedFlash||0; step++; }
      // Row4: MAX=현시값×1.5
      if (step<32) { setVeh(step); const mx = Math.round((ph.green||0)*1.5); ringA[step].max = mx; ringB[step].max = mx; step++; }
    } else {
      // Row1: MIN=15 고정
      setVeh(step); ringA[step].min = 15; ringB[step].min = 15; step++;
      // Row2: MAX=현시값×1.5
      if (step<32) { setVeh(step); const mx = Math.round((ph.green||0)*1.5); ringA[step].max = mx; ringB[step].max = mx; step++; }
    }
    // EOP: 황색
    if (step<32) {
      for (const n of nums) { if (lsus[n] !== "보행") { ringA[step].lsu[n-1] = 0x20; ringB[step].lsu[n-1] = 0x20; }}
      const yt = ph.yellow||3;
      ringA[step].min = yt; ringB[step].min = yt; ringA[step].eop = 1; ringB[step].eop = 1; step++;
    }
  }
  return { ringA, ringB, totalSteps: step };
}

// ═══════════════════════════════════════════════════════════════
//  DAT 읽기/쓰기
// ═══════════════════════════════════════════════════════════════
function readDat(buffer) {
  const d = new DataView(buffer); const u8 = new Uint8Array(buffer);
  const data = { dayPlans: [], ringA: [], ringB: [], lsuTypes: [], lsuActive: [], flash: {} };
  for (let p = 0; p < 10; p++) { const entries = []; for (let e = 0; e < 8; e++) { const off = DAT.TIMEPLAN_BASE + p*DAT.PLAN_SIZE + e*DAT.ENTRY_SIZE; const splits = []; for (let ph = 0; ph < 8; ph++) splits.push([u8[off+4+ph*2], u8[off+5+ph*2]]); entries.push({ hour: u8[off], min: u8[off+1], cycle: u8[off+2], offset: u8[off+3], splits }); } data.dayPlans.push(entries); }
  const readRing = (base) => { const steps = []; for (let s = 0; s < 32; s++) { const off = base+s*DAT.STEP_SIZE; const lsu = new Uint8Array(16); for (let i = 0; i < 16; i++) lsu[i] = u8[off+i]; steps.push({ lsu, min: u8[off+16], max: u8[off+17], eop: u8[off+18] }); } return steps; };
  data.ringA = readRing(DAT.RING_A); data.ringB = readRing(DAT.RING_B);
  for (let i = 0; i < 8; i++) data.lsuActive.push(u8[DAT.LSU_ACTIVE_FLAGS+i] === 1);
  for (let i = 0; i < 8; i++) data.lsuTypes.push({ t1: u8[DAT.LSU_TYPES+i*2], t2: u8[DAT.LSU_TYPES+i*2+1] });
  data.flash = { start: u8[DAT.FLASH_START], end: u8[DAT.FLASH_END] };
  let name = ""; for (let i = DAT.MFR_NAME; i < DAT.MFR_NAME+20 && u8[i]; i++) name += String.fromCharCode(u8[i]);
  data.mfr = { name, year: d.getUint16(DAT.MFR_DATE) };
  return data;
}
function writeDat(template, model) {
  const buf = template ? template.slice(0) : new ArrayBuffer(DAT.FILE_SIZE); const u8 = new Uint8Array(buf);
  if (model.dayPlans) { for (let p = 0; p < Math.min(model.dayPlans.length,10); p++) { for (let e = 0; e < Math.min(model.dayPlans[p].length,8); e++) { const off = DAT.TIMEPLAN_BASE+p*DAT.PLAN_SIZE+e*DAT.ENTRY_SIZE; const en = model.dayPlans[p][e]; u8[off]=en.hour||0; u8[off+1]=en.min||0; u8[off+2]=en.cycle||0; u8[off+3]=en.offset||0; for (let ph=0;ph<8;ph++){u8[off+4+ph*2]=en.splits?.[ph]?.[0]||0; u8[off+5+ph*2]=en.splits?.[ph]?.[1]||0;}}}}
  const writeRing = (base, steps) => { for (let s=0;s<32;s++){const off=base+s*DAT.STEP_SIZE; for(let i=0;i<16;i++) u8[off+i]=steps[s]?.lsu?.[i]||0; u8[off+16]=steps[s]?.min||0; u8[off+17]=steps[s]?.max||0; u8[off+18]=steps[s]?.eop||0;}};
  if (model.ringA) writeRing(DAT.RING_A, model.ringA); if (model.ringB) writeRing(DAT.RING_B, model.ringB);
  if (model.lsuActive) { for (let i=0;i<8;i++) u8[DAT.LSU_ACTIVE_FLAGS+i]=model.lsuActive[i]?1:0; }
  if (model.flash) { u8[DAT.FLASH_START]=model.flash.start||0; u8[DAT.FLASH_END]=model.flash.end||0; }
  return buf;
}

// ═══════════════════════════════════════════════════════════════
//  현시도 화살표 스프라이트 정의 + 합성
//  각 화살표를 정규화 좌표(paths/heads)로 정의, 균일 스케일링 배치
// ═══════════════════════════════════════════════════════════════

// 화살표 경로 정의: { w, h = 좌표계 크기, lw = 선굵기, dash = 점선여부,
//   paths = [[x1,y1,x2,y2,...]], heads = [[x1,y1,x2,y2,x3,y3]] (삼각형) }
const ARROWS = {
  // ── 세로 화살표 (30×70 좌표계) ──
  S_UP:          { w:30,h:70, lw:2.5, paths:[[15,66,15,13]],               heads:[[15,2,7,13,23,13]] },
  S_DOWN:        { w:30,h:70, lw:2.5, paths:[[15,4,15,57]],               heads:[[15,68,7,57,23,57]] },
  L_UP_LEFT:     { w:30,h:70, lw:2.5, paths:[[22,66,22,28,12,28]],        heads:[[2,28,12,21,12,35]] },
  L_DOWN_RIGHT:  { w:30,h:70, lw:2.5, paths:[[8,4,8,42,18,42]],          heads:[[28,42,18,35,18,49]] },
  P_VERT:        { w:30,h:70, lw:1.5, dash:true, paths:[[15,12,15,58]],   heads:[[15,3,9,12,21,12],[15,67,9,58,21,58]] },
  // ── 가로 화살표 (70×30 좌표계) ──
  S_LEFT:        { w:70,h:30, lw:2.5, paths:[[66,15,13,15]],              heads:[[2,15,13,7,13,23]] },
  S_RIGHT:       { w:70,h:30, lw:2.5, paths:[[4,15,57,15]],              heads:[[68,15,57,7,57,23]] },
  L_LEFT_DOWN:   { w:70,h:30, lw:2.5, paths:[[66,8,28,8,28,18]],         heads:[[28,28,21,18,35,18]] },
  L_RIGHT_UP:    { w:70,h:30, lw:2.5, paths:[[4,22,42,22,42,12]],        heads:[[42,2,35,12,49,12]] },
  P_HORIZ:       { w:70,h:30, lw:1.5, dash:true, paths:[[12,15,58,15]],   heads:[[3,15,12,9,12,21],[67,15,58,9,58,21]] },
};

// 단일 화살표를 (x, y, w, h) 영역에 렌더링 (좌표 수동 변환 → 선폭 일정)
function drawArrow(ctx, def, x, y, w, h) {
  const sx = w / def.w, sy = h / def.h;
  const tx = (px) => x + px * sx, ty = (py) => y + py * sy;
  ctx.save();
  ctx.strokeStyle = "#000"; ctx.fillStyle = "#000";
  ctx.lineWidth = def.lw; ctx.lineCap = "round"; ctx.lineJoin = "round";
  ctx.setLineDash(def.dash ? [4, 3] : []);
  for (const p of def.paths) {
    ctx.beginPath(); ctx.moveTo(tx(p[0]), ty(p[1]));
    for (let i = 2; i < p.length; i += 2) ctx.lineTo(tx(p[i]), ty(p[i + 1]));
    ctx.stroke();
  }
  ctx.setLineDash([]);
  for (const t of def.heads) {
    ctx.beginPath(); ctx.moveTo(tx(t[0]), ty(t[1])); ctx.lineTo(tx(t[2]), ty(t[3])); ctx.lineTo(tx(t[4]), ty(t[5])); ctx.closePath(); ctx.fill();
  }
  ctx.restore();
}

// 현시도 합성: phase 데이터 → PNG base64
function drawPhaseArrows(phase, lsuConfig, mode) {
  const W = 100, H = 80;
  const c = document.createElement("canvas"); c.width = W; c.height = H;
  const ctx = c.getContext("2d");
  ctx.fillStyle = "#fff"; ctx.fillRect(0, 0, W, H);

  const lsus = phase.lsus || {};
  const dirMap = {}; for (const lc of lsuConfig) dirMap[lc.lsu] = lc;

  // 요소 수집
  const straights = [], lefts = [];
  let pedCount = 0;
  for (const k in lsus) {
    const move = lsus[k]; if (!move || move === "—") continue;
    const cfg = dirMap[Number(k)]; if (!cfg) continue;
    if (cfg.type === "차량") {
      const s = move === "직진" || move === "직좌", l = move === "좌회전" || move === "직좌";
      if (mode === "all") { if (s) straights.push(cfg.dir); if (l) lefts.push(cfg.dir); }
      else if (mode === "ringA") { if (s) straights.push(cfg.dir); }
      else if (mode === "ringB") { if (l) lefts.push(cfg.dir); }
    }
    if (cfg.type === "보행" && move === "보행" && mode !== "ringB") pedCount++;
  }

  // 레이아웃: 남북=세로, 동서=가로
  const allD = straights.concat(lefts);
  const isV = allD.some(d => d === "북" || d === "남") || !allD.some(d => d === "동" || d === "서");

  // 방향 → 스프라이트 키 매핑
  const SK = { "북":"S_UP","남":"S_DOWN","동":"S_RIGHT","서":"S_LEFT" };
  const LK = { "북":"L_UP_LEFT","남":"L_DOWN_RIGHT","동":"L_RIGHT_UP","서":"L_LEFT_DOWN" };

  // 배열 순서: 보행은 양쪽 가장자리, 차량은 가운데
  const items = [];
  const pedKey = isV ? "P_VERT" : "P_HORIZ";
  const pedL = Math.ceil(pedCount / 2), pedR = Math.floor(pedCount / 2);
  const rev = isV ? allD.some(d => d === "남") : allD.some(d => d === "서");
  for (let p=0;p<pedL;p++) items.push(pedKey);
  if (isV) {
    if (rev) { straights.forEach(d => items.push(SK[d])); lefts.forEach(d => items.push(LK[d])); }
    else { lefts.forEach(d => items.push(LK[d])); straights.forEach(d => items.push(SK[d])); }
  } else {
    if (rev) { straights.forEach(d => items.push(SK[d])); lefts.forEach(d => items.push(LK[d])); }
    else { lefts.forEach(d => items.push(LK[d])); straights.forEach(d => items.push(SK[d])); }
  }
  for (let p=0;p<pedR;p++) items.push(pedKey);

  const n = items.length;
  if (n === 0) return c.toDataURL("image/png").replace(/^data:image\/png;base64,/, "");

  // 내부 패딩 (셀에 맞춰 채워질 때 여백 확보)
  const PX = W * 0.12, PY = H * 0.12;
  const IW = W - PX * 2, IH = H - PY * 2; // 내부 그리기 영역

  // 균일 스케일링으로 각 슬롯에 배치
  if (isV) {
    const slotW = IW / n;
    for (let i = 0; i < n; i++) {
      const def = ARROWS[items[i]];
      const scale = Math.min(slotW / def.w, IH / def.h);
      const dw = def.w * scale, dh = def.h * scale;
      drawArrow(ctx, def, PX + slotW * i + (slotW - dw) / 2, PY + (IH - dh) / 2, dw, dh);
    }
  } else {
    const slotH = IH / n;
    for (let i = 0; i < n; i++) {
      const def = ARROWS[items[i]];
      const scale = Math.min(IW / def.w, slotH / def.h);
      const dw = def.w * scale, dh = def.h * scale;
      drawArrow(ctx, def, PX + (IW - dw) / 2, PY + slotH * i + (slotH - dh) / 2, dw, dh);
    }
  }

  return c.toDataURL("image/png").replace(/^data:image\/png;base64,/, "");
}

// 교차로 도식 캔버스 (엑셀 삽입용, 흰배경+검은선)
function drawIntersection(activeRoads) {
  const Z = 200;
  const c = document.createElement("canvas"); c.width = Z; c.height = Z;
  const ctx = c.getContext("2d");
  ctx.fillStyle = "#fff"; ctx.fillRect(0, 0, Z, Z);
  const N = activeRoads.has("N"), S = activeRoads.has("S"), E = activeRoads.has("E"), W = activeRoads.has("W");
  const M = Z / 2, R = Z * 0.14, G = Z * 0.04;
  // 도로 외곽선
  ctx.strokeStyle = "#333"; ctx.lineWidth = 2; ctx.lineCap = "round";
  if (N) { ctx.beginPath(); ctx.moveTo(M-R,0); ctx.lineTo(M-R,M-R); ctx.stroke(); ctx.beginPath(); ctx.moveTo(M+R,0); ctx.lineTo(M+R,M-R); ctx.stroke(); }
  if (S) { ctx.beginPath(); ctx.moveTo(M-R,M+R); ctx.lineTo(M-R,Z); ctx.stroke(); ctx.beginPath(); ctx.moveTo(M+R,M+R); ctx.lineTo(M+R,Z); ctx.stroke(); }
  if (E) { ctx.beginPath(); ctx.moveTo(M+R,M-R); ctx.lineTo(Z,M-R); ctx.stroke(); ctx.beginPath(); ctx.moveTo(M+R,M+R); ctx.lineTo(Z,M+R); ctx.stroke(); }
  if (W) { ctx.beginPath(); ctx.moveTo(0,M-R); ctx.lineTo(M-R,M-R); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,M+R); ctx.lineTo(M-R,M+R); ctx.stroke(); }
  // 벽면
  if (!N) { ctx.beginPath(); ctx.moveTo(M-R,M-R); ctx.lineTo(M+R,M-R); ctx.stroke(); }
  if (!S) { ctx.beginPath(); ctx.moveTo(M-R,M+R); ctx.lineTo(M+R,M+R); ctx.stroke(); }
  if (!E) { ctx.beginPath(); ctx.moveTo(M+R,M-R); ctx.lineTo(M+R,M+R); ctx.stroke(); }
  if (!W) { ctx.beginPath(); ctx.moveTo(M-R,M-R); ctx.lineTo(M-R,M+R); ctx.stroke(); }
  // 중앙선
  ctx.lineWidth = 0.8;
  if (N) { ctx.beginPath(); ctx.moveTo(M,2); ctx.lineTo(M,M-R-G); ctx.stroke(); }
  if (S) { ctx.beginPath(); ctx.moveTo(M,M+R+G); ctx.lineTo(M,Z-2); ctx.stroke(); }
  if (E) { ctx.beginPath(); ctx.moveTo(M+R+G,M); ctx.lineTo(Z-2,M); ctx.stroke(); }
  if (W) { ctx.beginPath(); ctx.moveTo(2,M); ctx.lineTo(M-R-G,M); ctx.stroke(); }
  // 차선 (점선)
  ctx.setLineDash([5,5]); ctx.lineWidth = 0.6; const HR = R/2;
  if (N) { ctx.beginPath(); ctx.moveTo(M-HR,2); ctx.lineTo(M-HR,M-R-G); ctx.stroke(); ctx.beginPath(); ctx.moveTo(M+HR,2); ctx.lineTo(M+HR,M-R-G); ctx.stroke(); }
  if (S) { ctx.beginPath(); ctx.moveTo(M-HR,M+R+G); ctx.lineTo(M-HR,Z-2); ctx.stroke(); ctx.beginPath(); ctx.moveTo(M+HR,M+R+G); ctx.lineTo(M+HR,Z-2); ctx.stroke(); }
  if (E) { ctx.beginPath(); ctx.moveTo(M+R+G,M-HR); ctx.lineTo(Z-2,M-HR); ctx.stroke(); ctx.beginPath(); ctx.moveTo(M+R+G,M+HR); ctx.lineTo(Z-2,M+HR); ctx.stroke(); }
  if (W) { ctx.beginPath(); ctx.moveTo(2,M-HR); ctx.lineTo(M-R-G,M-HR); ctx.stroke(); ctx.beginPath(); ctx.moveTo(2,M+HR); ctx.lineTo(M-R-G,M+HR); ctx.stroke(); }
  ctx.setLineDash([]);
  // 횡단보도
  ctx.fillStyle = "#999"; const CW = Z*0.04, CL = R*2-4;
  const drawCW = (x,y,w,h,vert) => { const n=6; for(let i=0;i<n;i++){ if(vert) ctx.fillRect(x+i*(w/n),y,w/n*0.5,h); else ctx.fillRect(x,y+i*(h/n),w,h/n*0.5); }};
  if (N) drawCW(M-R+2, M-R-CW-3, CL, CW, true);
  if (S) drawCW(M-R+2, M+R+3, CL, CW, true);
  if (E) drawCW(M+R+3, M-R+2, CW, CL, false);
  if (W) drawCW(M-R-CW-3, M-R+2, CW, CL, false);
  // 방향 라벨
  ctx.fillStyle = "#666"; ctx.font = "bold 14px sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
  if (N) ctx.fillText("N", M, 12);
  if (S) ctx.fillText("S", M, Z-12);
  if (E) ctx.fillText("E", Z-12, M);
  if (W) ctx.fillText("W", 12, M);
  return c.toDataURL("image/png").replace(/^data:image\/png;base64,/, "");
}

// 현시 목록용 인라인 SVG 화살표 (drawPhaseArrows와 동일 로직)
function PhaseArrowsSvg({ phase, lsuConfig: lsuCfg }) {
  const lsus = phase.lsus || {};
  const dirMap = {}; for (const lc of lsuCfg) dirMap[lc.lsu] = lc;
  const straights = [], lefts = [];
  let pedCount = 0;
  for (const k in lsus) {
    const move = lsus[k]; if (!move || move === "—") continue;
    const cfg = dirMap[Number(k)]; if (!cfg) continue;
    if (cfg.type === "차량") {
      const s = move === "직진" || move === "직좌", l = move === "좌회전" || move === "직좌";
      if (s) straights.push(cfg.dir); if (l) lefts.push(cfg.dir);
    }
    if (cfg.type === "보행" && move === "보행") pedCount++;
  }
  const allD = straights.concat(lefts);
  if (allD.length === 0 && pedCount === 0) return null;
  const isV = allD.some(d => d === "북" || d === "남") || !allD.some(d => d === "동" || d === "서");
  const SK = { "북":"S_UP","남":"S_DOWN","동":"S_RIGHT","서":"S_LEFT" };
  const LK = { "북":"L_UP_LEFT","남":"L_DOWN_RIGHT","동":"L_RIGHT_UP","서":"L_LEFT_DOWN" };
  const items = [];
  const pedKey = isV ? "P_VERT" : "P_HORIZ";
  const pedL = Math.ceil(pedCount / 2), pedR = Math.floor(pedCount / 2);
  const rev = isV ? allD.some(d => d === "남") : allD.some(d => d === "서");
  for (let p=0;p<pedL;p++) items.push(pedKey);
  if (isV) {
    if (rev) { straights.forEach(d => items.push(SK[d])); lefts.forEach(d => items.push(LK[d])); }
    else { lefts.forEach(d => items.push(LK[d])); straights.forEach(d => items.push(SK[d])); }
  } else {
    if (rev) { straights.forEach(d => items.push(SK[d])); lefts.forEach(d => items.push(LK[d])); }
    else { lefts.forEach(d => items.push(LK[d])); straights.forEach(d => items.push(SK[d])); }
  }
  for (let p=0;p<pedR;p++) items.push(pedKey);
  if (items.length === 0) return null;
  const VW = 100, VH = 80, PX = VW * 0.08, PY = VH * 0.08;
  const IW = VW - PX * 2, IH = VH - PY * 2, n = items.length;
  const elems = [];
  if (isV) {
    const slotW = IW / n;
    items.forEach((key, i) => { const def = ARROWS[key]; const sc = Math.min(slotW / def.w, IH / def.h); const dw = def.w * sc, dh = def.h * sc; elems.push({ def, ox: PX + slotW * i + (slotW - dw) / 2, oy: PY + (IH - dh) / 2, sx: sc, sy: sc }); });
  } else {
    const slotH = IH / n;
    items.forEach((key, i) => { const def = ARROWS[key]; const sc = Math.min(IW / def.w, slotH / def.h); const dw = def.w * sc, dh = def.h * sc; elems.push({ def, ox: PX + (IW - dw) / 2, oy: PY + slotH * i + (slotH - dh) / 2, sx: sc, sy: sc }); });
  }
  const col = "#94a3b8";
  return (
    <svg viewBox={`0 0 ${VW} ${VH}`} style={{width:"100%",height:"100%"}}>
      {elems.map((e, i) => {
        const tx = px => e.ox + px * e.sx, ty = py => e.oy + py * e.sy;
        return (
          <g key={i}>
            {e.def.paths.map((p, pi) => { let d = `M${tx(p[0])},${ty(p[1])}`; for (let j = 2; j < p.length; j += 2) d += ` L${tx(p[j])},${ty(p[j+1])}`; return <path key={pi} d={d} fill="none" stroke={col} strokeWidth={e.def.lw} strokeLinecap="round" strokeLinejoin="round" strokeDasharray={e.def.dash ? "4,3" : "none"}/>; })}
            {e.def.heads.map((t, ti) => <polygon key={ti} points={`${tx(t[0])},${ty(t[1])} ${tx(t[2])},${ty(t[3])} ${tx(t[4])},${ty(t[5])}`} fill={col}/>)}
          </g>
        );
      })}
    </svg>
  );
}

// 교차로 모양 도식 SVG (activeRoads 기반 삼거리/사거리)
function IntersectionSvg({ activeRoads }) {
  const N = activeRoads.has("N"), S = activeRoads.has("S"), E = activeRoads.has("E"), W = activeRoads.has("W");
  const C = 50, R = 14, LN = "#333", LW = 1.2, TH = 0.4;
  // 횡단보도 줄무늬
  const cw = (x, y, w, h, vert, k) => {
    const n = 6, els = [];
    for (let i = 0; i < n; i++) els.push(vert
      ? <rect key={k+i} x={x + i * (w / n)} y={y} width={w / n * 0.5} height={h} fill="#888"/>
      : <rect key={k+i} x={x} y={y + i * (h / n)} width={w} height={h / n * 0.5} fill="#888"/>);
    return els;
  };
  return (
    <svg viewBox="0 0 100 100" style={{width:"100%",height:"100%"}}>
      <rect width="100" height="100" fill="#fff"/>
      {/* 도로 외곽선 */}
      {N && <><line x1={C-R} y1={0} x2={C-R} y2={C-R} stroke={LN} strokeWidth={LW}/><line x1={C+R} y1={0} x2={C+R} y2={C-R} stroke={LN} strokeWidth={LW}/></>}
      {S && <><line x1={C-R} y1={C+R} x2={C-R} y2={100} stroke={LN} strokeWidth={LW}/><line x1={C+R} y1={C+R} x2={C+R} y2={100} stroke={LN} strokeWidth={LW}/></>}
      {E && <><line x1={C+R} y1={C-R} x2={100} y2={C-R} stroke={LN} strokeWidth={LW}/><line x1={C+R} y1={C+R} x2={100} y2={C+R} stroke={LN} strokeWidth={LW}/></>}
      {W && <><line x1={0} y1={C-R} x2={C-R} y2={C-R} stroke={LN} strokeWidth={LW}/><line x1={0} y1={C+R} x2={C-R} y2={C+R} stroke={LN} strokeWidth={LW}/></>}
      {/* 벽면 (도로 없는 방향) */}
      {!N && <line x1={C-R} y1={C-R} x2={C+R} y2={C-R} stroke={LN} strokeWidth={LW}/>}
      {!S && <line x1={C-R} y1={C+R} x2={C+R} y2={C+R} stroke={LN} strokeWidth={LW}/>}
      {!E && <line x1={C+R} y1={C-R} x2={C+R} y2={C+R} stroke={LN} strokeWidth={LW}/>}
      {!W && <line x1={C-R} y1={C-R} x2={C-R} y2={C+R} stroke={LN} strokeWidth={LW}/>}
      {/* 중앙선 (실선) */}
      {N && <line x1={C} y1={1} x2={C} y2={C-R-4} stroke={LN} strokeWidth={TH}/>}
      {S && <line x1={C} y1={C+R+4} x2={C} y2={99} stroke={LN} strokeWidth={TH}/>}
      {E && <line x1={C+R+4} y1={C} x2={99} y2={C} stroke={LN} strokeWidth={TH}/>}
      {W && <line x1={1} y1={C} x2={C-R-4} y2={C} stroke={LN} strokeWidth={TH}/>}
      {/* 차선 (점선) */}
      {N && <><line x1={C-R/2} y1={1} x2={C-R/2} y2={C-R-4} stroke={LN} strokeWidth={TH} strokeDasharray="2,2"/><line x1={C+R/2} y1={1} x2={C+R/2} y2={C-R-4} stroke={LN} strokeWidth={TH} strokeDasharray="2,2"/></>}
      {S && <><line x1={C-R/2} y1={C+R+4} x2={C-R/2} y2={99} stroke={LN} strokeWidth={TH} strokeDasharray="2,2"/><line x1={C+R/2} y1={C+R+4} x2={C+R/2} y2={99} stroke={LN} strokeWidth={TH} strokeDasharray="2,2"/></>}
      {E && <><line x1={C+R+4} y1={C-R/2} x2={99} y2={C-R/2} stroke={LN} strokeWidth={TH} strokeDasharray="2,2"/><line x1={C+R+4} y1={C+R/2} x2={99} y2={C+R/2} stroke={LN} strokeWidth={TH} strokeDasharray="2,2"/></>}
      {W && <><line x1={1} y1={C-R/2} x2={C-R-4} y2={C-R/2} stroke={LN} strokeWidth={TH} strokeDasharray="2,2"/><line x1={1} y1={C+R/2} x2={C-R-4} y2={C+R/2} stroke={LN} strokeWidth={TH} strokeDasharray="2,2"/></>}
      {/* 횡단보도 */}
      {N && cw(C-R+1, C-R-6, R*2-2, 4, true, "n")}
      {S && cw(C-R+1, C+R+2, R*2-2, 4, true, "s")}
      {E && cw(C+R+2, C-R+1, 4, R*2-2, false, "e")}
      {W && cw(C-R-6, C-R+1, 4, R*2-2, false, "w")}
      {/* 방향 라벨 */}
      {N && <text x={C} y={7} textAnchor="middle" fontSize="6" fill="#666" fontWeight="700">N</text>}
      {S && <text x={C} y={97} textAnchor="middle" fontSize="6" fill="#666" fontWeight="700">S</text>}
      {E && <text x={95} y={C+2} textAnchor="end" fontSize="6" fill="#666" fontWeight="700">E</text>}
      {W && <text x={5} y={C+2} textAnchor="start" fontSize="6" fill="#666" fontWeight="700">W</text>}
    </svg>
  );
}

function CodeCell({ code }) {
  if (!code) return <div style={{ width:"100%",height:"100%",display:"flex",alignItems:"center",justifyContent:"center",background:"#1e1e2e",color:"#444" }}>·</div>;
  const info = STEP_CODES[code] || { label:`0x${code.toString(16)}`, short:code.toString(16).toUpperCase(), color:"#6b7280", text:"#fff" };
  return (<div title={`0x${code.toString(16).toUpperCase().padStart(2,"0")} ${info.label}`} style={{ width:"100%",height:"100%",display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",background:info.color,color:info.text,lineHeight:1.1 }}><span style={{fontSize:11,fontWeight:800}}>{info.short}</span><span style={{fontSize:9,opacity:0.85}}>{code.toString(16).toUpperCase().padStart(2,"0")}</span></div>);
}

// ═══════════════════════════════════════════════════════════════
//  메인 앱
// ═══════════════════════════════════════════════════════════════
export default function App() {
  const [tab, setTab] = useState("converter");
  const [template, setTemplate] = useState(null);
  const [fileName, setFileName] = useState("");
  const [lsuConfig] = useState(DEFAULT_LSU.map(c=>({...c})));
  const [convName, setConvName] = useState("");
  const [phases, setPhases] = useState([]);
  const [editIdx, setEditIdx] = useState(-1);
  const [periods, setPeriods] = useState([]);
  const [datData, setDatData] = useState(null);
  const [viewPlan, setViewPlan] = useState(0);
  const [statusMsg, setStatusMsg] = useState("준비");
  const [lsuPopup, setLsuPopup] = useState(null);
  const [simRunning, setSimRunning] = useState(false);
  const [simSpeed, setSimSpeed] = useState(1);
  const [simPeriodIdx, setSimPeriodIdx] = useState(0);
  const [simTime, setSimTime] = useState(0);
  const [simDensity, setSimDensity] = useState(2);
  const canvasRef = useRef(null);
  const animRef = useRef(null);
  const simTimeRef = useRef(0);
  const lastFrameRef = useRef(0);
  const simCarsRef = useRef([]);
  const simCarId = useRef(0);
  const spawnTimersRef = useRef({});
  const simPedsRef = useRef([]);
  const simPedId = useRef(0);
  const pedSpawnTimersRef = useRef({});
  const fileRef = useRef(null);
  const status = (msg) => setStatusMsg(msg);

  // ── LSU 클릭 ──
  const handleLsuClick = (lsuNum) => {
    if (editIdx < 0 || editIdx >= phases.length) return;
    const cfg = lsuConfig.find(c => c.lsu === lsuNum);
    if (!cfg) return;
    if (cfg.type === "보행") {
      // 보행은 단순 토글
      const next = [...phases];
      const ph = { ...next[editIdx], lsus: { ...next[editIdx].lsus } };
      if (ph.lsus[lsuNum]) delete ph.lsus[lsuNum];
      else ph.lsus[lsuNum] = "보행";
      next[editIdx] = ph; setPhases(next);
    } else {
      // 차량은 체크박스 팝업
      const cur = phases[editIdx]?.lsus?.[lsuNum] || "";
      setLsuPopup({
        lsuNum,
        straight: cur === "직진" || cur === "직좌",
        left: cur === "좌회전" || cur === "직좌",
      });
    }
  };

  // ── LSU 팝업 적용 ──
  const applyLsuPopup = () => {
    if (!lsuPopup || editIdx < 0) return;
    const { lsuNum, straight, left } = lsuPopup;
    const next = [...phases];
    const ph = { ...next[editIdx], lsus: { ...next[editIdx].lsus } };
    if (straight && left) ph.lsus[lsuNum] = "직좌";
    else if (straight) ph.lsus[lsuNum] = "직진";
    else if (left) ph.lsus[lsuNum] = "좌회전";
    else delete ph.lsus[lsuNum];
    next[editIdx] = ph; setPhases(next);
    setLsuPopup(null);
  };

  const addPhase = () => { setPhases([...phases, { lsus:{}, pedWait:1, pedGreen:0, pedFlash:0, yellow:3 }]); setEditIdx(phases.length); setLsuPopup(null); };
  const removePhase = (i) => { setPhases(phases.filter((_,idx)=>idx!==i)); if(editIdx===i) setEditIdx(-1); else if(editIdx>i) setEditIdx(editIdx-1); setLsuPopup(null); };
  const updatePF = (i,f,v) => { const next=[...phases]; next[i]={...next[i],[f]:Number(v)||0}; setPhases(next); };

  const getDesc = (ph) => { const lsus=ph.lsus||{}; const dirs=new Set(); const moveCnt={}; Object.keys(lsus).forEach(n=>{const c=lsuConfig.find(x=>x.lsu===Number(n)); if(c){ if(c.type!=="보행") dirs.add(c.dir); const m=lsus[n]; moveCnt[m]=(moveCnt[m]||0)+1;} }); if(dirs.size===0&&Object.keys(moveCnt).length===0) return "미설정"; const moveStr=Object.entries(moveCnt).map(([m,cnt])=>cnt>1?`${m}x${cnt}`:m).join("+"); return `${[...dirs].join("")} ${moveStr}`; };
  const isPed = (ph) => Object.values(ph.lsus||{}).includes("보행");

  // ── .dat 시그널맵 → 현시목록 역분석 ──
  const analyzePhases = (data) => {
    const rA = data.ringA || [], rB = data.ringB || [];
    const result = [];
    let start = 0;
    for (let s = 0; s < 32; s++) {
      if (rA[s]?.eop !== 1) continue;
      const cnt = s - start; // EOP 제외 행 수
      const ph = { lsus: {}, green: 0, pedWait: 0, pedGreen: 0, pedFlash: 0, yellow: rA[s].min || 3 };

      // LSU 이동류 판별 (EOP 이전 행들 스캔)
      // 보행 판별: LSU 타입(0x88) 또는 신호 패턴(0x01→0x05 순서)으로 감지
      const isPedType = (lIdx) => data.lsuTypes?.[lIdx]?.t1 === 0x88;
      const isPedPattern = (lIdx) => {
        let saw01 = false;
        for (let j = start; j < s; j++) {
          const cA = rA[j]?.lsu[lIdx] || 0;
          const cB = rB[j]?.lsu[lIdx] || 0;
          if (cA === 0x01 || cB === 0x01) saw01 = true;
          if ((cA === 0x05 || cB === 0x05) && saw01) return true;
        }
        return false;
      };
      for (let l = 0; l < 8; l++) {
        let hasSt = false, hasLeft = false, hasPedG = false, hasPedF = false;
        const ped = isPedType(l) || isPedPattern(l);
        for (let j = start; j < s; j++) {
          const cA = rA[j]?.lsu[l] || 0, cB = rB[j]?.lsu[l] || 0;
          if (cA === 0x10 || cB === 0x10) hasSt = true;
          if (cA === 0x01 || cB === 0x01) {
            if (ped) hasPedG = true;
            else hasLeft = true;
          }
          if (cA === 0x05 || cB === 0x05) {
            if (ped) hasPedF = true;
          }
        }
        const n = l + 1;
        if (hasPedG || hasPedF) ph.lsus[n] = "보행";
        else if (hasSt && hasLeft) ph.lsus[n] = "직좌";
        else if (hasSt) ph.lsus[n] = "직진";
        else if (hasLeft) ph.lsus[n] = "좌회전";
      }

      // 타이밍 역분석
      if (cnt === 4) {
        // 보행현시: pedWait, pedGreen, pedFlash, (MAX는 DAY PLAN에서)
        ph.pedWait = rA[start]?.min || 1;
        ph.pedGreen = rA[start + 1]?.min || 0;
        ph.pedFlash = rA[start + 2]?.min || 0;
      }

      result.push(ph);
      start = s + 1;
    }
    return result;
  };

  // ── 파일 I/O ──
  const handleFileOpen = useCallback((e) => {
    const file = e.target.files?.[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      let buf = ev.target.result;
      if (buf.byteLength > DAT.FILE_SIZE) { if(!confirm(`${buf.byteLength}B → ${DAT.FILE_SIZE}B 잘라 읽기?`)) return; buf=buf.slice(0,DAT.FILE_SIZE); }
      else if (buf.byteLength !== DAT.FILE_SIZE) { alert(`크기 오류: ${buf.byteLength}B`); return; }
      setTemplate(ev.target.result); setFileName(file.name);
      const data = readDat(buf); setDatData(data); setConvName(file.name.replace(/\.dat$/i,""));
      // 현시목록 역분석
      const ph = analyzePhases(data);
      if (ph.length > 0) { setPhases(ph); setEditIdx(0); }
      const plan0 = data.dayPlans?.[0];
      if (plan0) { const np=plan0.filter(e=>e.cycle>0).map(e=>({time:`${String(e.hour).padStart(2,"0")}:${String(e.min).padStart(2,"0")}`,cycle:e.cycle,offset:e.offset,ph:e.splits.map(([a])=>a)})); if(np.length>0) setPeriods(np); }
      setTab("signalmap"); status(`로드: ${file.name} (${ph.length}현시 감지)`);
    };
    reader.readAsArrayBuffer(file); e.target.value="";
  }, []);

  const handleSave = useCallback(async () => {
    if (!datData) { status("저장할 데이터 없음"); return; }
    const buf = writeDat(template, { ringA:datData.ringA, ringB:datData.ringB, dayPlans:datData.dayPlans, lsuActive:datData.lsuActive, flash:datData.flash });
    const name = convName ? `${convName}.dat` : fileName || "output.dat";
    const result = await saveFileWithDialog(new Uint8Array(buf), name, [{ name:"DAT 파일", extensions:["dat"] }]);
    if (result) status(`저장: ${typeof result === "string" && result.includes("\\") ? result : name}`);
  }, [datData, template, convName, fileName]);

  // ── ★ 맵핑 실행 ──
  const runConversion = () => {
    const valid = phases.filter(p => Object.keys(p.lsus||{}).length>0);
    if (valid.length===0) { status("현시를 정의하세요"); return; }
    if (periods.length===0) { alert("시간대별 타이밍을 입력하세요"); return; }

    // 각 현시별 최대값 가져오기 (모든 시간대에서 최대)
    const phaseMaxes = [];
    for (let i = 0; i < valid.length; i++) {
      let mx = 0;
      for (const p of periods) { if ((p.ph[i]||0) > mx) mx = p.ph[i]; }
      phaseMaxes.push(mx);
    }
    // 검증: 현시값 0인 현시 체크
    const missing = phaseMaxes.map((v,i)=>v===0?i+1:null).filter(Boolean);
    if (missing.length > 0) { alert(`${missing.join(",")}현시에 시간대별 타이밍 값이 없습니다.\nDAY PLAN 시간대에 현시값을 입력하세요.`); return; }

    // 현시에 green 값 주입 (MAX 계산용)
    const phasesWithGreen = valid.map((p,i) => ({...p, green: phaseMaxes[i]}));
    const result = generateSignalMap(phasesWithGreen, lsuConfig);
    const dayPlan = periods.map(p => { const [h,m]=(p.time||"0:0").split(":").map(Number); const cycle=p.ph.reduce((a,b)=>a+b,0); return {hour:h||0,min:m||0,cycle,offset:p.offset,splits:p.ph.map(v=>[v,v])}; });
    while(dayPlan.length<8) dayPlan.push({hour:0,min:0,cycle:0,offset:0,splits:Array(8).fill([0,0])});
    const dd = datData ? {...datData} : { dayPlans:Array(10).fill(null).map(()=>[...dayPlan]), lsuActive:lsuConfig.map(()=>true), flash:{start:23,end:6}, lsuTypes:[], mfr:{} };
    dd.dayPlans[0] = dayPlan; dd.ringA = result.ringA; dd.ringB = result.ringB;
    setDatData(dd); setTab("signalmap"); status(`맵핑 완료: ${valid.length}현시 → ${result.totalSteps}스텝`);
  };

  const loadExample = () => {
    setConvName("예제사거리");
    setCrossNo("190");
    setPhases([
      { lsus:{1:"직진",5:"직진",8:"보행",4:"보행"}, pedWait:1, pedGreen:11, pedFlash:7, yellow:3 },
      { lsus:{1:"좌회전"}, pedWait:0, pedGreen:0, pedFlash:0, yellow:3 },
      { lsus:{3:"직진",7:"직진",2:"보행",6:"보행"}, pedWait:1, pedGreen:9, pedFlash:6, yellow:3 },
      { lsus:{3:"좌회전"}, pedWait:0, pedGreen:0, pedFlash:0, yellow:3 },
    ]);
    setPeriods([{time:"00:00",cycle:130,offset:0,ph:[54,19,49,16,0,0,0,0]},{time:"07:00",cycle:150,offset:10,ph:[60,22,52,16,0,0,0,0]}]);
    setEditIdx(0); status("예제 로드");
  };

  const doReset = () => { if(!confirm("초기화?")) return; setDatData(null); setPhases([]); setPeriods([]); setConvName(""); setCrossNo(""); setTemplate(null); setFileName(""); setEditIdx(-1); setLsuPopup(null); setTab("converter"); status("초기화"); };

  // ═══════════════════════════════════════════════════════════════
  //  📊 엑셀 주기표 출력
  // ═══════════════════════════════════════════════════════════════
  const exportExcel = async () => {
    if(phases.length===0||periods.length===0){ setStatusMsg("현시와 타이밍을 먼저 정의하세요"); return; }
    try {
      if(!window.JSZip){
        setStatusMsg("라이브러리 로딩 중...");
        await new Promise(function(res,rej){
          var s=document.createElement("script");
          s.src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
          s.onload=res; s.onerror=function(){rej(new Error("JSZip 로드 실패"));}; document.head.appendChild(s);
        });
      }
      setStatusMsg("엑셀 생성 중...");
      var bin=atob(TMPL_B64); var buf=new Uint8Array(bin.length);
      for(var i=0;i<bin.length;i++) buf[i]=bin.charCodeAt(i);
      var zip=await window.JSZip.loadAsync(buf);
      var sheetXml=await zip.file("xl/worksheets/sheet1.xml").async("string");
      var escXml=function(s){return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");};
      var setCell=function(xml,ref,value){
        var isNum=typeof value==="number";
        var pat=new RegExp('<c r="'+ref+'"([^/]*?)(?:/>|>([\\s\\S]*?)</c>)');
        var m=xml.match(pat);
        if(!m) return xml;
        var attrs=m[1].replace(/\s*t="[^"]*"/g,"");
        var nc;
        if(isNum){nc='<c r="'+ref+'"'+attrs+'><v>'+value+'</v></c>';}
        else{nc='<c r="'+ref+'"'+attrs+' t="inlineStr"><is><t>'+escXml(value)+'</t></is></c>';}
        return xml.replace(pat,nc);
      };
      var nPh=Math.min(phases.length,6);
      var phCols=["J","L","N","P","R","T"];
      sheetXml=setCell(sheetXml,"D4",convName||"");
      for(var i=0;i<nPh;i++){sheetXml=setCell(sheetXml,phCols[i]+"14",i===0?20:10);sheetXml=setCell(sheetXml,phCols[i]+"15",i===0?20:10);}
      for(var i=0;i<nPh;i++){var minV=999999;for(var pi=0;pi<periods.length;pi++){var pv=periods[pi].ph[i]||0;if(pv>0&&pv<minV)minV=pv;}var v=minV>=999999?0:minV;sheetXml=setCell(sheetXml,phCols[i]+"16",v);sheetXml=setCell(sheetXml,phCols[i]+"17",v);}
      for(var i=0;i<nPh;i++){var mx=0;for(var pi=0;pi<periods.length;pi++){var pv=periods[pi].ph[i]||0;if(pv>mx)mx=pv;}sheetXml=setCell(sheetXml,phCols[i]+"18",mx);sheetXml=setCell(sheetXml,phCols[i]+"19",mx);}
      for(var i=0;i<nPh;i++){var yv=phases[i]?phases[i].yellow||3:3;sheetXml=setCell(sheetXml,phCols[i]+"20",yv);sheetXml=setCell(sheetXml,phCols[i]+"21",yv);}
      for(var i=0;i<nPh;i++){var pw=phases[i]?phases[i].pedWait||0:0;if(pw>0){sheetXml=setCell(sheetXml,phCols[i]+"22",pw);sheetXml=setCell(sheetXml,phCols[i]+"23",pw);}}
      for(var i=0;i<nPh;i++){var pg=phases[i]?phases[i].pedGreen||0:0;if(pg>0){sheetXml=setCell(sheetXml,phCols[i]+"24",pg);sheetXml=setCell(sheetXml,phCols[i]+"25",pg);}}
      for(var i=0;i<nPh;i++){var pf=phases[i]?phases[i].pedFlash||0:0;if(pf>0){sheetXml=setCell(sheetXml,phCols[i]+"26",pf);sheetXml=setCell(sheetXml,phCols[i]+"27",pf);}}
      var levelKeys=[];var levelList=[];
      for(var pi=0;pi<periods.length;pi++){var p=periods[pi];var cycle=0;for(var j=0;j<p.ph.length;j++)cycle+=(p.ph[j]||0);var sp=[];for(var j=0;j<p.ph.length;j++){if(p.ph[j]>0)sp.push(p.ph[j]);}var key=cycle+"_"+sp.join(",");if(levelKeys.indexOf(key)<0){levelKeys.push(key);levelList.push({cycle:cycle,offset:p.offset||0,splits:sp});}}
      var levelRows=[33,35,41,47,53,59];
      for(var li=0;li<levelList.length&&li<6;li++){var lv=levelList[li];var rr=levelRows[li];sheetXml=setCell(sheetXml,"B"+rr,lv.cycle);sheetXml=setCell(sheetXml,"C"+rr,li+1);sheetXml=setCell(sheetXml,"D"+rr,lv.offset);sheetXml=setCell(sheetXml,"E"+rr,lv.splits.join(","));var rrB=li===0?34:rr+1;sheetXml=setCell(sheetXml,"E"+rrB,lv.splits.join(","));}
      for(var pi=0;pi<periods.length&&pi<16;pi++){var p=periods[pi];var cycle=0;for(var j=0;j<p.ph.length;j++)cycle+=(p.ph[j]||0);var sp=[];for(var j=0;j<p.ph.length;j++){if(p.ph[j]>0)sp.push(p.ph[j]);}var key=cycle+"_"+sp.join(",");var lvIdx=levelKeys.indexOf(key);var rr=33+pi;sheetXml=setCell(sheetXml,"J"+rr,p.time||"00:00");sheetXml=setCell(sheetXml,"K"+rr,lvIdx+1);sheetXml=setCell(sheetXml,"L"+rr,lvIdx+1);}
      // ── 이미지 생성 및 XLSX 삽입 ──
      var imgList = []; // { name, b64, fromCol, toCol, fromRow, toRow, fit, aspect }
      var imgIdx = 0;
      // 교차로 도식 (정사각형, 1:1)
      var b64Cross = drawIntersection(activeRoads);
      imgIdx++; imgList.push({ name: "image" + imgIdx + ".png", b64: b64Cross, fromCol: 2, toCol: 9, fromRow: 5, toRow: 6, fit: 0.80, aspect: 1 });
      // 현시도
      var phColIdx = [9, 11, 13, 15, 17, 19]; // J,L,N,P,R,T (0-based)
      for (var pi2 = 0; pi2 < nPh; pi2++) {
        var ph2 = phases[pi2];
        // 현시도 (all) — 2행 전체 사용 (row 5→7)
        var b64All = drawPhaseArrows(ph2, lsuConfig, "all");
        imgIdx++; imgList.push({ name: "image" + imgIdx + ".png", b64: b64All, fromCol: phColIdx[pi2], toCol: phColIdx[pi2] + 2, fromRow: 5, toRow: 7, fit: 0.70 });
        // Ring A — 크기: 2행 기준 50%, 위치: 아랫칸(row8) 센터
        var b64A = drawPhaseArrows(ph2, lsuConfig, "ringA");
        imgIdx++; imgList.push({ name: "image" + imgIdx + ".png", b64: b64A, fromCol: phColIdx[pi2], toCol: phColIdx[pi2] + 2, fromRow: 7, toRow: 9, fit: 0.50, anchorRow: 8 });
        // Ring B — 크기: 2행 기준 50%, 위치: 윗칸(row9) 센터
        var b64B = drawPhaseArrows(ph2, lsuConfig, "ringB");
        imgIdx++; imgList.push({ name: "image" + imgIdx + ".png", b64: b64B, fromCol: phColIdx[pi2], toCol: phColIdx[pi2] + 2, fromRow: 9, toRow: 11, fit: 0.50, anchorRow: 9 });
      }

      if (imgList.length > 0) {
        // 1) xl/media/ 에 PNG 파일 추가
        for (var mi = 0; mi < imgList.length; mi++) {
          var raw = atob(imgList[mi].b64);
          var arr = new Uint8Array(raw.length);
          for (var bi = 0; bi < raw.length; bi++) arr[bi] = raw.charCodeAt(bi);
          zip.file("xl/media/" + imgList[mi].name, arr);
        }

        // 2) [Content_Types].xml 에 png 타입 추가
        var ctXml = await zip.file("[Content_Types].xml").async("string");
        if (ctXml.indexOf('Extension="png"') < 0) {
          ctXml = ctXml.replace("<Types ", '<Types ').replace(/<Types([^>]*)>/, '<Types$1><Default Extension="png" ContentType="image/png"/>');
        }
        // drawing 파트 타입 추가
        if (ctXml.indexOf('drawing+xml') < 0) {
          ctXml = ctXml.replace("</Types>", '<Override PartName="/xl/drawings/drawing1.xml" ContentType="application/vnd.openxmlformats-officedocument.drawing+xml"/></Types>');
        }
        zip.file("[Content_Types].xml", ctXml);

        // 3) xl/drawings/drawing1.xml 생성 (셀 크기 파싱 → oneCellAnchor 센터링)
        // ── 템플릿에서 열 너비/행 높이 파싱 ──
        var defaultColW = 8.43, defaultRowH = 15; // Excel 기본값
        var fmtM = sheetXml.match(/<sheetFormatPr[^>]*>/);
        if (fmtM) {
          var dcwM2 = fmtM[0].match(/defaultColWidth="([^"]+)"/);
          if (dcwM2) defaultColW = parseFloat(dcwM2[1]);
          var drhM2 = fmtM[0].match(/defaultRowHeight="([^"]+)"/);
          if (drhM2) defaultRowH = parseFloat(drhM2[1]);
        }
        var colWidths = {}, rowHeights2 = {};
        var colReg = /<col\s+[^>]*?\/>/g, colM2;
        while ((colM2 = colReg.exec(sheetXml)) !== null) {
          var mnM = colM2[0].match(/min="(\d+)"/), mxM = colM2[0].match(/max="(\d+)"/), cwM = colM2[0].match(/width="([^"]+)"/);
          if (mnM && mxM && cwM) for (var cc = parseInt(mnM[1]); cc <= parseInt(mxM[1]); cc++) colWidths[cc] = parseFloat(cwM[1]);
        }
        var rowReg = /<row\s+[^>]*?>/g, rowM2;
        while ((rowM2 = rowReg.exec(sheetXml)) !== null) {
          var rrM = rowM2[0].match(/r="(\d+)"/), htM = rowM2[0].match(/ht="([^"]+)"/);
          if (rrM && htM) rowHeights2[parseInt(rrM[1])] = parseFloat(htM[1]);
        }
        // 열 너비(문자) → EMU: px ≈ w*7+5, EMU = px*9525
        var colEMU = function(c1) { var w = colWidths[c1] || defaultColW; return Math.round((w * 7 + 5) * 9525); };
        // 행 높이(pt) → EMU: 1pt = 12700 EMU
        var rowEMU = function(r1) { var h = rowHeights2[r1] || defaultRowH; return Math.round(h * 12700); };

        var drawXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n';
        drawXml += '<xdr:wsDr xmlns:xdr="http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing" xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">\n';
        for (var di = 0; di < imgList.length; di++) {
          var im = imgList[di];
          var rId = "rId" + (di + 1);
          // 셀 범위의 총 EMU 계산 (0-based col/row → 1-based 변환)
          var rngW = 0, rngH = 0;
          for (var c = im.fromCol + 1; c <= im.toCol; c++) rngW += colEMU(c);
          for (var r = im.fromRow + 1; r <= im.toRow; r++) rngH += rowEMU(r);
          // 축소율 적용 + 비율 유지 (aspect: 기본 5:4, 교차로는 1:1)
          var fitRatio = im.fit || 0.85;
          var asp = im.aspect || (5 / 4); // width / height
          var fitW = Math.round(rngW * fitRatio), fitH = Math.round(rngH * fitRatio);
          var imgW, imgH;
          if (fitW / fitH > asp) { imgH = fitH; imgW = Math.round(imgH * asp); }
          else { imgW = fitW; imgH = Math.round(imgW / asp); }
          // 가로 센터링: 실제 앵커 열+오프셋 계산 (colOff가 열 너비 초과 방지)
          var centerX = Math.round((rngW - imgW) / 2);
          var aCol = im.fromCol, colOff = centerX;
          for (var cx = im.fromCol + 1; cx <= im.toCol && colOff >= colEMU(cx); cx++) {
            colOff -= colEMU(cx); aCol++;
          }
          // 수직 센터링: anchorRow가 지정되면 해당 1행 기준, 아니면 전체 범위 기준
          var aRow = im.anchorRow !== undefined ? im.anchorRow : im.fromRow;
          var rowOff;
          if (im.anchorRow !== undefined) {
            var cellH = rowEMU(im.anchorRow + 1); // 0-based → 1-based
            rowOff = Math.max(0, Math.round((cellH - imgH) / 2));
          } else {
            var centerY = Math.round((rngH - imgH) / 2);
            rowOff = centerY;
            for (var ry = im.fromRow + 1; ry <= im.toRow && rowOff >= rowEMU(ry); ry++) {
              rowOff -= rowEMU(ry); aRow++;
            }
          }
          drawXml += '<xdr:oneCellAnchor>';
          drawXml += '<xdr:from><xdr:col>' + aCol + '</xdr:col><xdr:colOff>' + colOff + '</xdr:colOff><xdr:row>' + aRow + '</xdr:row><xdr:rowOff>' + rowOff + '</xdr:rowOff></xdr:from>';
          drawXml += '<xdr:ext cx="' + imgW + '" cy="' + imgH + '"/>';
          drawXml += '<xdr:pic><xdr:nvPicPr><xdr:cNvPr id="' + (di + 2) + '" name="Img' + (di + 1) + '"/><xdr:cNvPicPr><a:picLocks noChangeAspect="1"/></xdr:cNvPicPr></xdr:nvPicPr>';
          drawXml += '<xdr:blipFill><a:blip r:embed="' + rId + '"/><a:stretch><a:fillRect/></a:stretch></xdr:blipFill>';
          drawXml += '<xdr:spPr><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></xdr:spPr>';
          drawXml += '</xdr:pic><xdr:clientData/></xdr:oneCellAnchor>\n';
        }
        drawXml += '</xdr:wsDr>';
        zip.file("xl/drawings/drawing1.xml", drawXml);

        // 4) xl/drawings/_rels/drawing1.xml.rels 생성
        var drawRels = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n';
        drawRels += '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n';
        for (var ri = 0; ri < imgList.length; ri++) {
          drawRels += '<Relationship Id="rId' + (ri + 1) + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="../media/' + imgList[ri].name + '"/>\n';
        }
        drawRels += '</Relationships>';
        zip.file("xl/drawings/_rels/drawing1.xml.rels", drawRels);

        // 5) xl/worksheets/_rels/sheet1.xml.rels 수정/생성
        var sheetRelsPath = "xl/worksheets/_rels/sheet1.xml.rels";
        var sheetRelsFile = zip.file(sheetRelsPath);
        var sheetRels;
        if (sheetRelsFile) {
          sheetRels = await sheetRelsFile.async("string");
          if (sheetRels.indexOf("drawing1.xml") < 0) {
            sheetRels = sheetRels.replace("</Relationships>", '<Relationship Id="rIdDrawing" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing" Target="../drawings/drawing1.xml"/></Relationships>');
          }
        } else {
          sheetRels = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rIdDrawing" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing" Target="../drawings/drawing1.xml"/></Relationships>';
        }
        zip.file(sheetRelsPath, sheetRels);

        // 6) sheet1.xml 에 <drawing> 참조 추가 + r: 네임스페이스 보장
        if (sheetXml.indexOf("<drawing ") < 0 && sheetXml.indexOf("<drawing>") < 0) {
          // worksheet 태그에 r: 네임스페이스가 없으면 추가
          if (sheetXml.indexOf('xmlns:r=') < 0) {
            sheetXml = sheetXml.replace(/<worksheet([^>]*)>/, '<worksheet$1 xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">');
          }
          sheetXml = sheetXml.replace("</worksheet>", '<drawing r:id="rIdDrawing"/></worksheet>');
        }
      }
      // ── 현시도 삽입 완료 ──

      zip.file("xl/worksheets/sheet1.xml",sheetXml);
      var xlsxBlob=await zip.generateAsync({type:"blob",mimeType:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"});
      var xlsxName=(convName||"주기표")+".xlsx";
      var result=await saveFileWithDialog(xlsxBlob, xlsxName, [{name:"Excel 파일",extensions:["xlsx"]}]);
      if(result) setStatusMsg("엑셀 주기표 저장 완료: "+(typeof result==="string"&&result.includes("\\")?result:xlsxName));
    }catch(e){setStatusMsg("엑셀 오류: "+e.message);console.error(e);}
  };

  const updatePeriod = (i,f,v) => { const next=[...periods]; if(f.startsWith("ph")){const idx=parseInt(f.slice(2)); next[i]={...next[i],ph:next[i].ph.map((x,j)=>(j===idx?Number(v)||0:x))};} else {next[i]={...next[i],[f]:f==="time"?v:Number(v)||0};} setPeriods(next); };
  const addPeriod = () => setPeriods([...periods,{time:"00:00",cycle:0,offset:0,ph:[0,0,0,0,0,0,0,0]}]);

  // ═══════════════════════════════════════════════════════════════
  //  🚦 Canvas 시뮬레이션 엔진
  // ═══════════════════════════════════════════════════════════════
  const SIM_W = 700, SIM_H = 700;
  const SCX = 350, SCY = 340, SRW = 60, SLW = 30;
  const CAR_W = 20, CAR_H = 11, STOP_D = 45, CAR_GAP = 26;
  const LSU_DIR = { 1:"N", 3:"E", 5:"S", 7:"W" };
  const CAR_COLORS = ["#3B82F6","#EF4444","#F59E0B","#10B981","#8B5CF6","#EC4899","#F97316","#06B6D4","#84CC16","#6366F1","#FBBF24","#14B8A6","#E11D48","#A855F7","#1E293B","#FFFFFF","#0F172A","#334155"];

  // 도로/신호 존재 판단
  // - 도로(activeRoads): LSU에 직진/직좌 있으면 해당 방향 + 신호 있으면 반대편(진입로)
  // - 신호(activeSignals): LSU가 어떤 현시에든 있으면 표시
  const { activeRoads, activeSignals } = useMemo(() => {
    const roads = new Set();
    const signals = new Set();
    const oppositeDir = {N:"S", S:"N", E:"W", W:"E"};
    phases.forEach(ph => {
      if (!ph.lsus) return;
      Object.entries(ph.lsus).forEach(([lsu, mov]) => {
        const d = LSU_DIR[Number(lsu)];
        if (!d) return;
        signals.add(d);
        if (mov === "직진" || mov === "직좌") roads.add(d);
      });
    });
    // 신호가 있는 방향 → 반대편 도로 필요 (차량 진입로)
    signals.forEach(d => roads.add(oppositeDir[d]));
    return {
      activeRoads: roads.size > 0 ? roads : new Set(["N","S","E","W"]),
      activeSignals: signals.size > 0 ? signals : new Set(["N","S","E","W"])
    };
  }, [phases]);

  // LSU 현시 → 방향별 신호상태 계산
  const getSignalState = useCallback((time) => {
    if (phases.length === 0 || periods.length === 0) return { dirSignals:{}, pedSignals:{}, phaseIdx:-1, remaining:0, cycle:0 };
    const period = periods[simPeriodIdx] || periods[0];
    const phaseDurs = phases.map((_,i) => period.ph[i]||0);
    const cycle = phaseDurs.reduce((a,b)=>a+b,0);
    if (cycle===0) return { dirSignals:{}, pedSignals:{}, phaseIdx:-1, remaining:0, cycle };
    const t = ((time % cycle)+cycle) % cycle;
    let elapsed=0, curIdx=0;
    for (let i=0;i<phases.length;i++){if(phaseDurs[i]===0)continue;if(t<elapsed+phaseDurs[i]){curIdx=i;break;}elapsed+=phaseDurs[i];}
    const ph = phases[curIdx], dur=phaseDurs[curIdx], tip=t-elapsed, yel=ph.yellow||3;
    const isYel = tip >= dur-yel;
    const remaining = dur-tip;

    // 방향별 신호: { straight:"green"|"red"|"yellow", left:"green"|"red"|"yellow", countdown }
    const dirSignals = {};
    for (const dir of ["N","S","E","W"]) {
      const lsu = {N:1,S:5,E:3,W:7}[dir];
      const move = ph.lsus?.[lsu] || null;
      let straight="red", left="red", countdown=Math.ceil(remaining);
      if (move) {
        if (isYel) { straight="yellow"; left="yellow"; }
        else {
          if (move==="직진"||move==="직좌") straight="green";
          if (move==="좌회전"||move==="직좌") left="green";
        }
        countdown = isYel ? Math.ceil(dur-tip) : Math.ceil(dur-yel-tip);
      } else {
        // 적색 카운트다운: 다음 녹색까지
        let rem = dur-tip;
        for (let j=1;j<=phases.length;j++){const ni=(curIdx+j)%phases.length;const np=phases[ni];const nd=phaseDurs[ni];if(nd===0)continue;if(np.lsus?.[lsu]){countdown=Math.ceil(rem);break;}rem+=nd;}
      }
      dirSignals[dir] = { straight, left, countdown };
    }
    // 보행 신호
    const pedSignals = {};
    const pedLsuDir = {8:"N",2:"E",4:"S",6:"W"};
    for (const [lsuStr,dir] of Object.entries(pedLsuDir)) {
      const lsu=Number(lsuStr);
      const move = ph.lsus?.[lsu] || null;
      let state="red", countdown=Math.ceil(remaining);
      if (move) {
        const pw=ph.pedWait||0, pg=ph.pedGreen||0, pf=ph.pedFlash||0;
        if(tip<pw) { state="red"; countdown=Math.ceil(pw-tip); }
        else if(tip<pw+pg) { state="green"; countdown=Math.ceil(pw+pg-tip); }
        else if(tip<pw+pg+pf) { state=Math.floor(time*3)%2===0?"green":"off"; countdown=Math.ceil(pw+pg+pf-tip); }
        else { state="red"; countdown=0; }
      } else {
        let rem=dur-tip;
        for(let j=1;j<=phases.length;j++){const ni=(curIdx+j)%phases.length;const np=phases[ni];const nd=phaseDurs[ni];if(nd===0)continue;if(np.lsus?.[lsu]){countdown=Math.ceil(rem);break;}rem+=nd;}
      }
      const flashing = move && tip>=(ph.pedWait||0)+(ph.pedGreen||0) && tip<(ph.pedWait||0)+(ph.pedGreen||0)+(ph.pedFlash||0);
      const timeToEnd = move ? Math.max(0,(ph.pedWait||0)+(ph.pedGreen||0)+(ph.pedFlash||0)-tip) : 0;
      pedSignals[dir] = { state, countdown, flashing, timeToEnd };
    }
    return { dirSignals, pedSignals, phaseIdx:curIdx, remaining, cycle, phaseName:getDesc(ph), phaseDurs };
  }, [phases, periods, simPeriodIdx]);

  const dirToVec = (d) => ({N:{x:0,y:-1},S:{x:0,y:1},E:{x:1,y:0},W:{x:-1,y:0}}[d]);
  const leftTarget = (d) => ({N:"W",S:"E",E:"N",W:"S"}[d]);
  const rightTarget = (d) => ({N:"E",S:"W",E:"S",W:"N"}[d]);
  const oppositeDir = (d) => ({N:"S",S:"N",E:"W",W:"E"}[d]);
  const stopLinePos = (d) => ({N:SCY+SRW+STOP_D-16,S:SCY-SRW-STOP_D+16,E:SCX-SRW-STOP_D+16,W:SCX+SRW+STOP_D-16}[d]);

  const getLaneX = (dir, lane) => {
    if(dir==="N") return lane==="inner" ? SCX+SLW/2 : SCX+SLW+SLW/2;
    if(dir==="S") return lane==="inner" ? SCX-SLW/2 : SCX-SLW-SLW/2;
    return null;
  };
  const getLaneY = (dir, lane) => {
    if(dir==="E") return lane==="inner" ? SCY+SLW/2 : SCY+SLW+SLW/2;
    if(dir==="W") return lane==="inner" ? SCY-SLW/2 : SCY-SLW-SLW/2;
    return null;
  };

  const spawnCar = (dir,movement) => {
    const lane = movement==="left" ? "inner" : "outer";
    let x,y;
    // 1차선(중앙선쪽)=좌회전, 2차선(바깥쪽)=직진
    if(dir==="N"){x=getLaneX(dir,lane);y=SIM_H+16;}
    else if(dir==="S"){x=getLaneX(dir,lane);y=-16;}
    else if(dir==="E"){y=getLaneY(dir,lane);x=-16;}
    else{y=getLaneY(dir,lane);x=SIM_W+16;}
    const c=CAR_COLORS[Math.floor(Math.random()*CAR_COLORS.length)];
    return{id:simCarId.current++,dir,movement,x,y,speed:55+Math.random()*15,maxSpeed:55+Math.random()*15,color:c,turning:false,turnProgress:0,turnStartX:0,turnStartY:0,done:false,passedStop:false,lane,laneChanging:false,blockedTime:0};
  };

  // refs for latest state
  const phasesRef = useRef(phases); phasesRef.current = phases;
  const periodsRef = useRef(periods); periodsRef.current = periods;
  const simPeriodRef = useRef(simPeriodIdx); simPeriodRef.current = simPeriodIdx;
  const simSpeedRef = useRef(simSpeed); simSpeedRef.current = simSpeed;
  const simDensityRef = useRef(simDensity); simDensityRef.current = simDensity;
  const activeRoadsRef = useRef(activeRoads); activeRoadsRef.current = activeRoads;
  const activeSignalsRef = useRef(activeSignals); activeSignalsRef.current = activeSignals;

  useEffect(() => {
    if (!simRunning || tab !== "simulation") { if(animRef.current) cancelAnimationFrame(animRef.current); return; }
    const canvas = canvasRef.current; if(!canvas) return;
    const ctx = canvas.getContext("2d");
    lastFrameRef.current = performance.now();

    const draw = (timestamp) => {
      const rawDt = (timestamp - lastFrameRef.current)/1000;
      lastFrameRef.current = timestamp;
      const dt = Math.min(rawDt,0.1) * simSpeedRef.current;
      simTimeRef.current += dt;
      const time = simTimeRef.current;
      if(Math.floor(time*2)!==Math.floor((time-dt)*2)) setSimTime(time);

      const sigState = getSignalState(time);
      const { dirSignals, pedSignals, phaseIdx, remaining, cycle, phaseName, phaseDurs } = sigState;

      // ── Spawn ── 
      // 진입: opposite(dir) 도로 필요, 직진: dir 도로 필요, 회전: 회전출구 도로 필요
      const timers = spawnTimersRef.current;
      const interval = 3.2 / simDensityRef.current;
      const aDirs = activeRoadsRef.current;
      ["N","S","E","W"].forEach(dir=>{
        if(!aDirs.has(oppositeDir(dir))) return; // 진입로 없으면 스폰 불가
        const canStraight = aDirs.has(dir);             // 직진 출구
        const canLeft = aDirs.has(leftTarget(dir));      // 좌회전 출구
        const canRight = aDirs.has(rightTarget(dir));    // 우회전 출구
        ["inner","outer"].forEach(lane=>{
          // 1차선(inner): 좌회전 우선, 불가면 직진 / 2차선(outer): 직진 우선, 불가면 우회전
          let mov;
          if(lane==="inner"){
            if(canLeft) mov="left";
            else if(canStraight) mov="straight";
            else return; // 둘 다 불가 → 스폰 안 함
          } else {
            if(canStraight) mov="straight";
            else if(canRight) mov="right";
            else return;
          }
          const k=`${dir}_${lane}`;
          timers[k]=(timers[k]||0)+dt;
          if(timers[k]>interval*(lane==="inner"?1.8:1)){
            const sameLane=simCarsRef.current.filter(c=>c.dir===dir&&c.lane===lane&&!c.done&&!c.turning);
            let canSpawn=true;
            for(const c of sameLane){
              if(dir==="N"&&c.y>SIM_H-60) canSpawn=false;
              if(dir==="S"&&c.y<60) canSpawn=false;
              if(dir==="E"&&c.x<60) canSpawn=false;
              if(dir==="W"&&c.x>SIM_W-60) canSpawn=false;
            }
            if(canSpawn){
              let finalMov = mov;
              // 2차선 직진 중 25% 우회전 (우회전 가능할 때)
              if(lane==="outer" && mov==="straight" && canRight && Math.random()<0.25) finalMov="right";
              simCarsRef.current.push(spawnCar(dir,finalMov));
              timers[k]=0;
            }
          }
        });
      });

      // ── Update cars (앞차부터 처리: 큐잉 보장) ──
      const cars = simCarsRef.current;
      // 방향별 진행 순서로 정렬 (앞차 먼저)
      const sortKey = (c) => {
        if(c.dir==="N") return -c.y;  // y 작을수록 앞
        if(c.dir==="S") return c.y;   // y 클수록 앞
        if(c.dir==="E") return c.x;   // x 클수록 앞
        return -c.x;                  // x 작을수록 앞
      };
      cars.sort((a,b)=>sortKey(b)-sortKey(a));

      cars.forEach(car=>{
        if(car.done)return;
        const vec=dirToVec(car.dir);
        const isVert=car.dir==="N"||car.dir==="S";
        const sig=dirSignals[car.dir];
        const stopLine=stopLinePos(car.dir);
        const hardGap=CAR_H+6;

        // 우회전 충돌 체크: 보행신호 + 경로 중간점 + 출구
        const canRightTurn = () => {
          const rtDir = rightTarget(car.dir);
          // 횡단보도 보행 신호가 녹색/점멸이면 무조건 정지
          const rtPed = pedSignals?.[rtDir];
          if(rtPed && (rtPed.state==="green" || rtPed.flashing)) return false;
          // 경로 체크 포인트: 중간점(교차로 모서리)과 출구
          let midX, midY, exitX, exitY;
          if(car.dir==="N"){
            midX=SCX+SLW+SLW/2; midY=SCY+SRW;
            exitX=SCX+SRW+30; exitY=SCY+SLW+SLW/2;
          } else if(car.dir==="S"){
            midX=SCX-SLW-SLW/2; midY=SCY-SRW;
            exitX=SCX-SRW-30; exitY=SCY-SLW-SLW/2;
          } else if(car.dir==="E"){
            midX=SCX-SRW; midY=SCY+SLW+SLW/2;
            exitX=SCX-SLW-SLW/2; exitY=SCY+SRW+30;
          } else {
            midX=SCX+SRW; midY=SCY-SLW-SLW/2;
            exitX=SCX+SLW+SLW/2; exitY=SCY-SRW-30;
          }
          // 보행자 실제 좌표 계산 (progress/cw/laneOff → px,py)
          const roadW = SRW*2;
          const peds = simPedsRef.current;
          for(const p of peds){
            if(p.done) continue;
            if(p.cw !== rtDir) continue;
            let px, py;
            if(p.cw==="N"||p.cw==="S"){
              px = SCX-SRW + p.progress*roadW;
              py = p.cw==="N" ? SCY-SRW-19+p.laneOff : SCY+SRW+19+p.laneOff;
            } else {
              py = SCY-SRW + p.progress*roadW;
              px = p.cw==="E" ? SCX+SRW+19+p.laneOff : SCX-SRW-19+p.laneOff;
            }
            const dxE = Math.abs(px-exitX), dyE = Math.abs(py-exitY);
            const dxM = Math.abs(px-midX), dyM = Math.abs(py-midY);
            if((dxE<45&&dyE<45)||(dxM<45&&dyM<45)) return false;
          }
          // 차량: 중간점 또는 출구 근처
          for(const o of cars){
            if(o.id===car.id||o.done) continue;
            if(o.dir===car.dir) continue;
            const dxM = Math.abs(o.x-midX), dyM = Math.abs(o.y-midY);
            const dxE = Math.abs(o.x-exitX), dyE = Math.abs(o.y-exitY);
            if((dxM<40&&dyM<40)||(dxE<40&&dyE<40)) return false;
          }
          return true;
        };

        const canGo=(car.movement==="straight"&&sig?.straight==="green")||(car.movement==="left"&&sig?.left==="green")||car.movement==="right"||(sig?.straight==="yellow"&&car.passedStop);

        // 좌회전 진입
        if(car.movement==="left"&&!car.turning&&car.passedStop){
          if(Math.abs(car.x-SCX)<SRW+8&&Math.abs(car.y-SCY)<SRW+8){car.turning=true;car.turnStartX=car.x;car.turnStartY=car.y;car.turnProgress=0;}
        }
        // 우회전 진입: 매 프레임 충돌 체크, 비어있으면 즉시 진입
        if(car.movement==="right"&&!car.turning&&car.passedStop){
          if(Math.abs(car.x-SCX)<SRW+20&&Math.abs(car.y-SCY)<SRW+20){
            if(canRightTurn()){ car.turning=true;car.turnStartX=car.x;car.turnStartY=car.y;car.turnProgress=0;car.turnType="right";car.rightWaiting=false; }
          }
        }

        if(car.turning){
          // 우회전 중 충돌 체크: 보행신호/보행자/차량 감속
          let turnBlocked = false;
          if(car.turnType==="right"){
            // 횡단보도 근처에서 보행 신호 녹색/점멸이면 정지
            const rtDir=rightTarget(car.dir);
            const rtPed=pedSignals?.[rtDir];
            if(rtPed && (rtPed.state==="green" || rtPed.flashing)){
              // 횡단보도 위치에 근접한지 체크
              let nearCW=false;
              if(rtDir==="N"||rtDir==="S"){
                const cwY=rtDir==="N"?SCY-SRW-19:SCY+SRW+19;
                if(Math.abs(car.y-cwY)<30) nearCW=true;
              } else {
                const cwX=rtDir==="E"?SCX+SRW+19:SCX-SRW-19;
                if(Math.abs(car.x-cwX)<30) nearCW=true;
              }
              if(nearCW) turnBlocked=true;
            }
            const roadW=SRW*2;
            const ta = car.turnAngle!=null ? car.turnAngle : Math.atan2(vec.y,vec.x);
            const tdx = Math.cos(ta), tdy = Math.sin(ta);
            const peds=simPedsRef.current;
            for(const p of peds){
              if(p.done) continue;
              let px,py;
              if(p.cw==="N"||p.cw==="S"){
                px=SCX-SRW+p.progress*roadW;
                py=p.cw==="N"?SCY-SRW-19+p.laneOff:SCY+SRW+19+p.laneOff;
              } else {
                py=SCY-SRW+p.progress*roadW;
                px=p.cw==="E"?SCX+SRW+19+p.laneOff:SCX-SRW-19+p.laneOff;
              }
              const dpx=px-car.x, dpy=py-car.y;
              const ahead=dpx*tdx+dpy*tdy;
              if(ahead>0 && Math.abs(dpx)<30&&Math.abs(dpy)<30){turnBlocked=true;break;}
            }
            if(!turnBlocked){
              for(const o of cars){
                if(o.id===car.id||o.done) continue;
                const dpx=o.x-car.x, dpy=o.y-car.y;
                const ahead=dpx*tdx+dpy*tdy;
                if(ahead>0 && Math.abs(dpx)<28&&Math.abs(dpy)<28){turnBlocked=true;break;}
              }
            }
          }
          if(turnBlocked){
            car.speed=Math.max(0,car.speed-400*dt);
          } else {
            car.speed=Math.min(car.maxSpeed,car.speed+90*dt);
          }
          car.turnProgress+=dt*(car.speed/80);
          const t2=Math.min(car.turnProgress,1);
          const ease=t2*t2*(3-2*t2);
          let p0x,p0y,p1x,p1y,p2x,p2y;

          if(car.turnType==="right"){
            // 우회전 베지어
            if(car.dir==="N"){
              p0x=car.turnStartX;p0y=car.turnStartY;
              p1x=car.turnStartX;p1y=SCY+SLW+SLW/2;
              p2x=SCX+SRW+30;p2y=SCY+SLW+SLW/2;
            } else if(car.dir==="S"){
              p0x=car.turnStartX;p0y=car.turnStartY;
              p1x=car.turnStartX;p1y=SCY-SLW-SLW/2;
              p2x=SCX-SRW-30;p2y=SCY-SLW-SLW/2;
            } else if(car.dir==="E"){
              p0x=car.turnStartX;p0y=car.turnStartY;
              p1x=SCX-SLW-SLW/2;p1y=car.turnStartY;
              p2x=SCX-SLW-SLW/2;p2y=SCY+SRW+30;
            } else {
              p0x=car.turnStartX;p0y=car.turnStartY;
              p1x=SCX+SLW+SLW/2;p1y=car.turnStartY;
              p2x=SCX+SLW+SLW/2;p2y=SCY-SRW-30;
            }
          } else {
            // 좌회전 베지어
            if(car.dir==="N"){
              p0x=car.turnStartX;p0y=car.turnStartY;
              p1x=car.turnStartX;p1y=SCY-SLW/2;
              p2x=SCX-SRW-30;p2y=SCY-SLW/2;
            } else if(car.dir==="S"){
              p0x=car.turnStartX;p0y=car.turnStartY;
              p1x=car.turnStartX;p1y=SCY+SLW/2;
              p2x=SCX+SRW+30;p2y=SCY+SLW/2;
            } else if(car.dir==="E"){
              p0x=car.turnStartX;p0y=car.turnStartY;
              p1x=SCX+SLW/2;p1y=car.turnStartY;
              p2x=SCX+SLW/2;p2y=SCY-SRW-30;
            } else {
              p0x=car.turnStartX;p0y=car.turnStartY;
              p1x=SCX-SLW/2;p1y=car.turnStartY;
              p2x=SCX-SLW/2;p2y=SCY+SRW+30;
            }
          }

          const mt=1-ease;
          car.x = mt*mt*p0x + 2*mt*ease*p1x + ease*ease*p2x;
          car.y = mt*mt*p0y + 2*mt*ease*p1y + ease*ease*p2y;
          const tx = 2*mt*(p1x-p0x) + 2*ease*(p2x-p1x);
          const ty = 2*mt*(p1y-p0y) + 2*ease*(p2y-p1y);
          car.turnAngle = Math.atan2(ty,tx);

          if(car.turnProgress>=1){
            car.turning=false;car.x=p2x;car.y=p2y;
            car.dir=car.turnType==="right"?rightTarget(car.dir):leftTarget(car.dir);
            car.movement="straight";car.passedStop=true;
            car.turnAngle=undefined;car.turnType=undefined;
          }
        } else {
          // ── 차선 변경 애니메이션 ──
          if(car.laneChanging){
            const targetPos = isVert ? getLaneX(car.dir, car.lane) : getLaneY(car.dir, car.lane);
            const currentPos = isVert ? car.x : car.y;
            if(targetPos !== null){
              const diff = targetPos - currentPos;
              const step = 120 * dt;
              if(Math.abs(diff) < step){
                if(isVert) car.x = targetPos; else car.y = targetPos;
                car.laneChanging = false;
              } else {
                const move = Math.sign(diff) * step;
                if(isVert) car.x += move; else car.y += move;
              }
            } else {
              car.laneChanging = false;
            }
          }

          // ── 최대 이동 가능 거리 계산 ──
          let maxMove = Infinity;

          // a) 정지선까지 거리
          if(!car.passedStop&&!canGo){
            const dToStop = isVert ? (car.y-stopLine)*-vec.y : (car.x-stopLine)*-vec.x;
            if(dToStop>0) maxMove=Math.min(maxMove, dToStop);
            else maxMove=0;  // 이미 정지선 위치
          }

          // b) 우회전: 충돌 위험 시 교차로 직전에서 감속 정지
          if(car.movement==="right"&&car.passedStop&&!car.turning&&!canRightTurn()){
              let dToTurn;
              if(car.dir==="N") dToTurn=car.y-(SCY+SRW+2);
              else if(car.dir==="S") dToTurn=(SCY-SRW-2)-car.y;
              else if(car.dir==="E") dToTurn=(SCX-SRW-2)-car.x;
              else dToTurn=car.x-(SCX+SRW+2);
              if(dToTurn>0) maxMove=Math.min(maxMove,dToTurn);
              else maxMove=0;
          }

          // c) 앞차까지 거리 - hardGap (같은 방향 같은 차선)
          cars.forEach(o=>{
            if(o.id===car.id||o.done||o.turning)return;
            if(o.dir!==car.dir)return;
            if(car.lane!==o.lane)return;
            let df;
            if(isVert) df=(car.y-o.y)*-vec.y;
            else df=(car.x-o.x)*-vec.x;
            if(df>0){
              const allowedDist = df - hardGap;
              maxMove = Math.min(maxMove, Math.max(0, allowedDist));
            }
          });


          // ── 차선 변경 판정 ──
          if(car.movement==="straight" && !car.passedStop && !car.laneChanging){
            if(maxMove < 5 && car.speed < 5){
              car.blockedTime = (car.blockedTime||0) + dt;
            } else {
              car.blockedTime = 0;
            }
            if(car.blockedTime > 1.2){
              const targetLane = car.lane==="outer" ? "inner" : "outer";
              // 인접 차선에 전방 50px ~ 후방 35px 범위 내 차량 없는지 확인
              const carPos = isVert ? car.y : car.x;
              let laneEmpty = true;
              for(const o of cars){
                if(o.id===car.id||o.done||o.turning)continue;
                if(o.dir!==car.dir||o.lane!==targetLane)continue;
                const oPos = isVert ? o.y : o.x;
                const along = (carPos - oPos) * (isVert ? -vec.y : -vec.x);
                // along > 0 = 앞차, along < 0 = 뒷차
                if(along > -35 && along < 50){ laneEmpty=false; break; }
              }
              if(laneEmpty){
                car.lane = targetLane;
                car.laneChanging = true;
                car.blockedTime = 0;
              }
            }
          } else if(car.movement!=="straight" || car.passedStop){
            car.blockedTime = 0;
          }

          // 감속/가속
          if(maxMove < 30){
            car.speed = Math.max(0, car.speed - (maxMove<5 ? 500 : 250) * dt);
          } else {
            car.speed = Math.min(car.maxSpeed, car.speed + 90 * dt);
          }

          // 실제 이동 (최대 거리로 클램프)
          const wantMove = car.speed * dt;
          const actualMove = Math.min(wantMove, Math.max(0, maxMove));
          car.x += vec.x * actualMove;
          car.y += vec.y * actualMove;
          if(actualMove < 0.01) car.speed = 0;

          if(!car.passedStop){
            if(car.dir==="N"&&car.y<=stopLine)car.passedStop=true;
            if(car.dir==="S"&&car.y>=stopLine)car.passedStop=true;
            if(car.dir==="E"&&car.x>=stopLine)car.passedStop=true;
            if(car.dir==="W"&&car.x<=stopLine)car.passedStop=true;
          }
        }

        if(car.passedStop&&(car.x<-50||car.x>SIM_W+50||car.y<-50||car.y>SIM_H+50))car.done=true;
      });
      simCarsRef.current=cars.filter(c=>!c.done);

      // ── 보행자 Spawn (녹색일때만, 점멸 중 스폰 금지) ──
      const pedTimers = pedSpawnTimersRef.current;
      const pedInterval = 2.5 / simDensityRef.current;
      ["N","S","E","W"].forEach(cw=>{
        const ps = pedSignals?.[cw];
        if(ps && (ps.state==="green" || ps.state==="off") && ps.timeToEnd>=6){
          const k=`ped_${cw}`;
          pedTimers[k]=(pedTimers[k]||0)+dt;
          if(pedTimers[k]>pedInterval){
            const flipDir = Math.random()>0.5 ? 1 : -1;
            const laneOff = (Math.random()-0.5)*16;
            const walkSpeed = 18+Math.random()*10;
            const colors=["#F9A8D4","#93C5FD","#FDE68A","#A7F3D0","#C4B5FD","#FCA5A5","#FDBA74"];
            simPedsRef.current.push({
              id:simPedId.current++, cw, dir:flipDir, progress:flipDir>0?0:1,
              laneOff, speed:walkSpeed, baseSpeed:walkSpeed,
              color:colors[Math.floor(Math.random()*colors.length)],
              walkPhase:Math.random()*Math.PI*2, done:false
            });
            pedTimers[k]=0;
          }
        }
      });

      // ── 보행자 Update ──
      simPedsRef.current.forEach(ped=>{
        if(ped.done)return;
        const ps = pedSignals?.[ped.cw];
        const isGreen = ps && (ps.state==="green" || ps.state==="off");
        // 점멸이면 뛰기! (속도 2.5배)
        if(ps && ps.flashing){
          ped.speed = ped.baseSpeed * 2.5;
        } else {
          ped.speed = ped.baseSpeed;
        }
        // 녹색이거나 이미 건너기 시작했으면 계속 이동
        if(isGreen || (ped.dir>0?ped.progress>0.05:ped.progress<0.95)){
          ped.progress += ped.dir * (ped.speed/140) * dt;
          ped.walkPhase += dt * (ps?.flashing ? 18 : 10);  // 점멸시 다리 빠르게
        }
        if(ped.progress<-0.05||ped.progress>1.05) ped.done=true;
      });
      simPedsRef.current=simPedsRef.current.filter(p=>!p.done);

      // ═══ DRAW ═══
      ctx.clearRect(0,0,SIM_W,SIM_H);
      ctx.fillStyle="#0B1120";ctx.fillRect(0,0,SIM_W,SIM_H);
      const ad = activeRoadsRef.current;
      const asSig = activeSignalsRef.current;
      const hasN=ad.has("N"),hasS=ad.has("S"),hasE=ad.has("E"),hasW=ad.has("W");
      const hasVert=hasN||hasS, hasHoriz=hasE||hasW;
      // 잔디 패턴
      ctx.fillStyle="rgba(255,255,255,0.008)";
      for(let gx=0;gx<SIM_W;gx+=40)for(let gy=0;gy<SIM_H;gy+=40)if((gx+gy)%80===0)ctx.fillRect(gx,gy,40,40);
      // 도로 (활성 방향만)
      ctx.fillStyle="#1A2332";
      if(hasVert){
        if(hasN) ctx.fillRect(SCX-SRW,0,SRW*2,SCY+SRW);
        if(hasS) ctx.fillRect(SCX-SRW,SCY-SRW,SRW*2,SIM_H-SCY+SRW);
        if(!hasN&&!hasS) ctx.fillRect(SCX-SRW,SCY-SRW,SRW*2,SRW*2);
      }
      if(hasHoriz){
        if(hasW) ctx.fillRect(0,SCY-SRW,SCX+SRW,SRW*2);
        if(hasE) ctx.fillRect(SCX-SRW,SCY-SRW,SIM_W-SCX+SRW,SRW*2);
      }
      // 교차로 중심 (항상)
      if(hasVert||hasHoriz) ctx.fillRect(SCX-SRW,SCY-SRW,SRW*2,SRW*2);
      // 도로 경계
      ctx.strokeStyle="#2A3A4E";ctx.lineWidth=1.5;
      if(hasN){[SCX-SRW,SCX+SRW].forEach(x=>{ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,SCY-SRW);ctx.stroke();});}
      if(hasS){[SCX-SRW,SCX+SRW].forEach(x=>{ctx.beginPath();ctx.moveTo(x,SCY+SRW);ctx.lineTo(x,SIM_H);ctx.stroke();});}
      if(hasW){[SCY-SRW,SCY+SRW].forEach(y=>{ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(SCX-SRW,y);ctx.stroke();});}
      if(hasE){[SCY-SRW,SCY+SRW].forEach(y=>{ctx.beginPath();ctx.moveTo(SCX+SRW,y);ctx.lineTo(SIM_W,y);ctx.stroke();});}
      // 없는 방향 벽면
      if(!hasN){ctx.beginPath();ctx.moveTo(SCX-SRW,SCY-SRW);ctx.lineTo(SCX+SRW,SCY-SRW);ctx.stroke();}
      if(!hasS){ctx.beginPath();ctx.moveTo(SCX-SRW,SCY+SRW);ctx.lineTo(SCX+SRW,SCY+SRW);ctx.stroke();}
      if(!hasE){ctx.beginPath();ctx.moveTo(SCX+SRW,SCY-SRW);ctx.lineTo(SCX+SRW,SCY+SRW);ctx.stroke();}
      if(!hasW){ctx.beginPath();ctx.moveTo(SCX-SRW,SCY-SRW);ctx.lineTo(SCX-SRW,SCY+SRW);ctx.stroke();}
      // 차선 (점선)
      ctx.strokeStyle="rgba(255,255,255,0.1)";ctx.lineWidth=1;ctx.setLineDash([7,7]);
      if(hasN){[SCX-SLW,SCX+SLW].forEach(x=>{ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,SCY-SRW-4);ctx.stroke();});}
      if(hasS){[SCX-SLW,SCX+SLW].forEach(x=>{ctx.beginPath();ctx.moveTo(x,SCY+SRW+4);ctx.lineTo(x,SIM_H);ctx.stroke();});}
      if(hasW){[SCY-SLW,SCY+SLW].forEach(y=>{ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(SCX-SRW-4,y);ctx.stroke();});}
      if(hasE){[SCY-SLW,SCY+SLW].forEach(y=>{ctx.beginPath();ctx.moveTo(SCX+SRW+4,y);ctx.lineTo(SIM_W,y);ctx.stroke();});}
      ctx.setLineDash([]);
      // 중앙선
      ctx.strokeStyle="rgba(251,191,36,0.25)";ctx.lineWidth=1.5;
      if(hasN){ctx.beginPath();ctx.moveTo(SCX,0);ctx.lineTo(SCX,SCY-SRW-4);ctx.stroke();}
      if(hasS){ctx.beginPath();ctx.moveTo(SCX,SCY+SRW+4);ctx.lineTo(SCX,SIM_H);ctx.stroke();}
      if(hasW){ctx.beginPath();ctx.moveTo(0,SCY);ctx.lineTo(SCX-SRW-4,SCY);ctx.stroke();}
      if(hasE){ctx.beginPath();ctx.moveTo(SCX+SRW+4,SCY);ctx.lineTo(SIM_W,SCY);ctx.stroke();}
      // 횡단보도 (보행 신호에 따라 색 변화)
      const cwOff=SRW+8,cwW=22;
      const pN=pedSignals?.["N"]||{state:"red"};
      const pS=pedSignals?.["S"]||{state:"red"};
      const pE=pedSignals?.["E"]||{state:"red"};
      const pW=pedSignals?.["W"]||{state:"red"};
      const cwColor=(ps)=>{
        if(ps.state==="green") return "rgba(34,197,94,0.45)";
        if(ps.state==="off") return "transparent";  // flash off
        return "rgba(239,68,68,0.2)";  // red
      };
      const cwGlow=(ps)=>{
        if(ps.state==="green") return "#22C55E";
        return null;
      };
      // 북 횡단보도 (N과 인접 방향 있을 때)
      if(hasN){
        const ncw=cwColor(pN), ng=cwGlow(pN);
        if(ng){ctx.shadowColor=ng;ctx.shadowBlur=8;}
        for(let x=SCX-SRW+3;x<SCX+SRW-3;x+=7){ctx.fillStyle=ncw;ctx.fillRect(x,SCY-cwOff-cwW,3.5,cwW);}
        ctx.shadowBlur=0;
      }
      // 남 횡단보도
      if(hasS){
        const scw=cwColor(pS), sg=cwGlow(pS);
        if(sg){ctx.shadowColor=sg;ctx.shadowBlur=8;}
        for(let x=SCX-SRW+3;x<SCX+SRW-3;x+=7){ctx.fillStyle=scw;ctx.fillRect(x,SCY+cwOff,3.5,cwW);}
        ctx.shadowBlur=0;
      }
      // 동 횡단보도
      if(hasE){
        const ecw=cwColor(pE), eg=cwGlow(pE);
        if(eg){ctx.shadowColor=eg;ctx.shadowBlur=8;}
        for(let y=SCY-SRW+3;y<SCY+SRW-3;y+=7){ctx.fillStyle=ecw;ctx.fillRect(SCX+cwOff,y,cwW,3.5);}
        ctx.shadowBlur=0;
      }
      // 서 횡단보도
      if(hasW){
        const wcw=cwColor(pW), wg=cwGlow(pW);
        if(wg){ctx.shadowColor=wg;ctx.shadowBlur=8;}
        for(let y=SCY-SRW+3;y<SCY+SRW-3;y+=7){ctx.fillStyle=wcw;ctx.fillRect(SCX-cwOff-cwW,y,cwW,3.5);}
        ctx.shadowBlur=0;
      }
      // 정지선
      ctx.strokeStyle="rgba(255,255,255,0.3)";ctx.lineWidth=2;
      if(hasN){ctx.beginPath();ctx.moveTo(SCX,SCY+SRW+10);ctx.lineTo(SCX+SRW,SCY+SRW+10);ctx.stroke();}
      if(hasS){ctx.beginPath();ctx.moveTo(SCX-SRW,SCY-SRW-10);ctx.lineTo(SCX,SCY-SRW-10);ctx.stroke();}
      if(hasE){ctx.beginPath();ctx.moveTo(SCX-SRW-10,SCY);ctx.lineTo(SCX-SRW-10,SCY+SRW);ctx.stroke();}
      if(hasW){ctx.beginPath();ctx.moveTo(SCX+SRW+10,SCY-SRW);ctx.lineTo(SCX+SRW+10,SCY);ctx.stroke();}
      // 교차로 영역
      ctx.fillStyle="rgba(255,255,255,0.02)";ctx.fillRect(SCX-SRW,SCY-SRW,SRW*2,SRW*2);
      // 도로 화살표
      ctx.fillStyle="rgba(255,255,255,0.06)";ctx.font="12px sans-serif";ctx.textAlign="center";ctx.textBaseline="middle";
      if(hasN){ctx.fillText("↰",SCX+SLW/2,SCY+SRW+40);ctx.fillText("↑",SCX+SLW+SLW/2,SCY+SRW+40);}
      if(hasS){ctx.fillText("↱",SCX-SLW/2,SCY-SRW-40);ctx.fillText("↓",SCX-SLW-SLW/2,SCY-SRW-40);}
      if(hasE){ctx.fillText("↰",SCX-SRW-40,SCY+SLW/2);ctx.fillText("→",SCX-SRW-40,SCY+SLW+SLW/2);}
      if(hasW){ctx.fillText("↱",SCX+SRW+40,SCY-SLW/2);ctx.fillText("←",SCX+SRW+40,SCY-SLW-SLW/2);}

      // ── 보행자 그리기 ──
      simPedsRef.current.forEach(ped=>{
        if(ped.done)return;
        let px,py;
        const roadW=SRW*2;
        if(ped.cw==="N"){
          px=SCX-SRW + ped.progress*roadW;
          py=SCY-cwOff-cwW/2 + ped.laneOff;
        } else if(ped.cw==="S"){
          px=SCX-SRW + ped.progress*roadW;
          py=SCY+cwOff+cwW/2 + ped.laneOff;
        } else if(ped.cw==="E"){
          py=SCY-SRW + ped.progress*roadW;
          px=SCX+cwOff+cwW/2 + ped.laneOff;
        } else {
          py=SCY-SRW + ped.progress*roadW;
          px=SCX-cwOff-cwW/2 + ped.laneOff;
        }
        const legSwing=Math.sin(ped.walkPhase)*3;
        ctx.save();ctx.translate(px,py);
        // 그림자
        ctx.fillStyle="rgba(0,0,0,0.25)";
        ctx.beginPath();ctx.ellipse(0,6,3,1.5,0,0,Math.PI*2);ctx.fill();
        // 다리
        ctx.strokeStyle=ped.color;ctx.lineWidth=1.2;ctx.lineCap="round";
        ctx.beginPath();ctx.moveTo(0,2);ctx.lineTo(-legSwing,6);ctx.stroke();
        ctx.beginPath();ctx.moveTo(0,2);ctx.lineTo(legSwing,6);ctx.stroke();
        // 몸
        ctx.beginPath();ctx.moveTo(0,-1);ctx.lineTo(0,2);ctx.stroke();
        // 머리
        ctx.fillStyle=ped.color;
        ctx.beginPath();ctx.arc(0,-3,2.2,0,Math.PI*2);ctx.fill();
        ctx.restore();
      });

      // ── 차량 신호등 함수 정의 ──
      const drawVehicleSignal = (sx,sy,sig,label,rot=0) => {
        ctx.save();ctx.translate(sx,sy);ctx.rotate(rot);
        const bw=56,bh=18;
        ctx.fillStyle="rgba(10,15,25,0.95)";ctx.strokeStyle="#334155";ctx.lineWidth=1;
        ctx.beginPath();ctx.roundRect(-bw/2,-bh/2,bw,bh,4);ctx.fill();ctx.stroke();
        const on={red:"#EF4444",yellow:"#FACC15",arrow:"#22C55E",green:"#22C55E"};
        const off={red:"#2a1111",yellow:"#2a2211",arrow:"#112a11",green:"#112a11"};
        const isRed=sig.straight==="red"&&sig.left==="red";
        const isYel=sig.straight==="yellow";
        const arrowOn=sig.left==="green";
        const greenOn=sig.straight==="green";
        const lights=[
          {c:isRed?on.red:off.red, glow:isRed},
          {c:isYel?on.yellow:off.yellow, glow:isYel},
          {c:arrowOn?on.arrow:off.arrow, glow:arrowOn, isArrow:true},
          {c:greenOn?on.green:off.green, glow:greenOn},
        ];
        lights.forEach((l,i)=>{
          const lx=-21+i*14;
          if(l.isArrow){
            // 좌회전: 검은 바탕 + 굵은 화살표
            ctx.fillStyle="#0A0F19";
            ctx.beginPath();ctx.arc(lx,0,4.5,0,Math.PI*2);ctx.fill();
            if(l.glow){
              ctx.shadowColor="#22C55E";ctx.shadowBlur=8;
              // 굵은 화살표 직접 그리기
              ctx.strokeStyle="#22C55E";ctx.lineWidth=2;ctx.lineCap="round";ctx.lineJoin="round";
              ctx.beginPath();
              ctx.moveTo(lx+2.5,0);ctx.lineTo(lx-2,0); // 줄기
              ctx.moveTo(lx-0.5,-2.2);ctx.lineTo(lx-2.5,0);ctx.lineTo(lx-0.5,2.2); // 화살촉
              ctx.stroke();
              ctx.shadowBlur=0;ctx.lineCap="butt";ctx.lineJoin="miter";
            } else {
              // 꺼진 상태: 어두운 화살표
              ctx.strokeStyle="#1a3a1a";ctx.lineWidth=1.5;ctx.lineCap="round";ctx.lineJoin="round";
              ctx.beginPath();
              ctx.moveTo(lx+2,0);ctx.lineTo(lx-1.5,0);
              ctx.moveTo(lx-0.3,-1.8);ctx.lineTo(lx-2,0);ctx.lineTo(lx-0.3,1.8);
              ctx.stroke();
              ctx.lineCap="butt";ctx.lineJoin="miter";
            }
          } else {
            if(l.glow){ctx.shadowColor=l.c;ctx.shadowBlur=10;}
            ctx.fillStyle=l.c;
            ctx.beginPath();ctx.arc(lx,0,4.5,0,Math.PI*2);ctx.fill();
            ctx.shadowBlur=0;
          }
        });
        ctx.restore();
        const cdColor=isRed?"#EF4444":isYel?"#FACC15":"#22C55E";
        const cdx=sx+Math.sin(rot)*24, cdy=sy+Math.cos(rot)*24;
        ctx.fillStyle="rgba(0,0,0,0.9)";ctx.beginPath();ctx.roundRect(cdx-12,cdy-8,24,16,3);ctx.fill();
        ctx.strokeStyle=isRed?"#7f1d1d":isYel?"#713f12":"#14532d";ctx.lineWidth=1;
        ctx.beginPath();ctx.roundRect(cdx-12,cdy-8,24,16,3);ctx.stroke();
        ctx.fillStyle=cdColor;ctx.font="bold 12px 'Courier New',monospace";ctx.textAlign="center";ctx.textBaseline="middle";
        ctx.fillText(String(sig.countdown||0),cdx,cdy);
        const lbx=sx-Math.sin(rot)*18, lby=sy-Math.cos(rot)*18;
        ctx.fillStyle="#64748B";ctx.font="bold 9px sans-serif";ctx.textAlign="center";ctx.textBaseline="middle";
        ctx.fillText(label,lbx,lby);
      };

      // 방향 라벨 (활성 방향만)
      ctx.fillStyle="#475569";ctx.font="bold 12px sans-serif";ctx.textAlign="center";
      if(hasN) ctx.fillText("북 (N)",SCX,16);
      if(hasS) ctx.fillText("남 (S)",SCX,SIM_H-8);
      if(hasW){ctx.save();ctx.translate(14,SCY);ctx.rotate(-Math.PI/2);ctx.fillText("서 (W)",0,0);ctx.restore();}
      if(hasE){ctx.save();ctx.translate(SIM_W-14,SCY);ctx.rotate(Math.PI/2);ctx.fillText("동 (E)",0,0);ctx.restore();}

      // ── 차량 (먼저 그림) ──
      const dirAngle={N:-Math.PI/2,S:Math.PI/2,E:0,W:Math.PI};
      simCarsRef.current.forEach(car=>{
        if(car.done)return;
        const angle = car.turning && car.turnAngle!==undefined ? car.turnAngle : (dirAngle[car.dir]||0);
        ctx.save();ctx.translate(car.x,car.y);ctx.rotate(angle);
        ctx.fillStyle="rgba(0,0,0,0.3)";ctx.beginPath();ctx.roundRect(-CAR_W/2+1,-CAR_H/2+1,CAR_W,CAR_H,2.5);ctx.fill();
        ctx.fillStyle=car.color;ctx.beginPath();ctx.roundRect(-CAR_W/2,-CAR_H/2,CAR_W,CAR_H,2.5);ctx.fill();
        ctx.fillStyle="rgba(0,0,0,0.25)";ctx.fillRect(CAR_W/2-6,-CAR_H/2+1.5,4,CAR_H-3);
        if(car.speed<8){ctx.fillStyle="#EF4444";ctx.shadowColor="#EF4444";ctx.shadowBlur=5;ctx.fillRect(-CAR_W/2,-CAR_H/2+1,1.5,2.5);ctx.fillRect(-CAR_W/2,CAR_H/2-3.5,1.5,2.5);ctx.shadowBlur=0;}
        if(car.movement==="left"&&!car.turning&&Math.sin(time*8)>0){ctx.fillStyle="#FBBF24";ctx.shadowColor="#FBBF24";ctx.shadowBlur=3;ctx.fillRect(CAR_W/2-1.5,-CAR_H/2,1.5,2.5);ctx.shadowBlur=0;}
        if(car.movement==="right"&&!car.turning&&Math.sin(time*8)>0){ctx.fillStyle="#FBBF24";ctx.shadowColor="#FBBF24";ctx.shadowBlur=3;ctx.fillRect(CAR_W/2-1.5,CAR_H/2-2.5,1.5,2.5);ctx.shadowBlur=0;}
        ctx.restore();
      });

      // ── 신호등 (활성 신호 방향만 - 도로 없어도 LSU 있으면 표시) ──
      const sN=dirSignals["N"]||{straight:"red",left:"red",countdown:0};
      const sS=dirSignals["S"]||{straight:"red",left:"red",countdown:0};
      const sE=dirSignals["E"]||{straight:"red",left:"red",countdown:0};
      const sW=dirSignals["W"]||{straight:"red",left:"red",countdown:0};
      if(asSig.has("N")) drawVehicleSignal(SCX+SLW, SCY-SRW-50, sN, "LSU1", 0);
      if(asSig.has("S")) drawVehicleSignal(SCX-SLW, SCY+SRW+50, sS, "LSU5", Math.PI);
      if(asSig.has("E")) drawVehicleSignal(SCX+SRW+50, SCY+SLW, sE, "LSU3", Math.PI/2);
      if(asSig.has("W")) drawVehicleSignal(SCX-SRW-50, SCY-SLW, sW, "LSU7", -Math.PI/2);

      // ── 현시 배너 (우측 상단, 최상위) ──
      if(phaseIdx>=0){
        const txt=`${phaseIdx+1}현시 · ${phaseName||""} · ${Math.ceil(remaining)}s`;
        ctx.font="bold 11px sans-serif";const tw=ctx.measureText(txt).width;
        const bx=SIM_W-tw-30, by=8;
        ctx.fillStyle="rgba(0,0,0,0.8)";ctx.beginPath();ctx.roundRect(bx,by,tw+20,22,5);ctx.fill();
        ctx.strokeStyle="rgba(245,158,11,0.4)";ctx.lineWidth=1;ctx.beginPath();ctx.roundRect(bx,by,tw+20,22,5);ctx.stroke();
        ctx.fillStyle="#F59E0B";ctx.textAlign="center";ctx.textBaseline="middle";ctx.fillText(txt,bx+tw/2+10,by+11);
      }

      // ── 타이밍 바 (캔버스 하단) ──
      if(phaseDurs&&cycle>0){
        const barY=SIM_H-30,barH=14,barX=30,barW=SIM_W-60;
        ctx.fillStyle="rgba(0,0,0,0.5)";ctx.beginPath();ctx.roundRect(barX-2,barY-2,barW+4,barH+4,4);ctx.fill();
        const phCols=["#22d3ee","#a78bfa","#f472b6","#34d399","#f59e0b","#ef4444","#6366f1","#ec4899"];
        let bx=barX;
        phaseDurs.forEach((d,i)=>{
          if(d===0)return;
          const w=d/cycle*barW;
          ctx.fillStyle=i===phaseIdx?phCols[i%phCols.length]:"#1e293b";
          ctx.fillRect(bx,barY,w-1,barH);
          if(w>20){ctx.fillStyle=i===phaseIdx?"#000":"#64748b";ctx.font="9px sans-serif";ctx.textAlign="center";ctx.textBaseline="middle";ctx.fillText(`${i+1}현시 ${d}s`,bx+w/2,barY+barH/2);}
          bx+=w;
        });
      }

      // ── DEBUG: 우회전 체크 상태 ──
      ctx.font="bold 9px monospace";ctx.textAlign="left";ctx.textBaseline="top";
      const dbgY=50;
      ["N","S","E","W"].forEach((d,i)=>{
        const rt=({N:"E",S:"W",E:"S",W:"N"})[d];
        const cp=pedSignals?.[rt];
        const cv=dirSignals?.[rt];
        const pedSt=cp?cp.state:"없음";
        const vehSt=cv?`s:${cv.straight} l:${cv.left}`:"없음";
        const ok=(!cp||cp.state==="red")&&(!cv||(cv.straight!=="green"&&cv.left!=="green"));
        ctx.fillStyle=ok?"#22c55e":"#ef4444";
        ctx.fillText(`${d}→${rt}: ped=${pedSt} veh=${vehSt} → ${ok?"GO":"STOP"}`,8,dbgY+i*12);
      });

      animRef.current = requestAnimationFrame(draw);
    };
    animRef.current = requestAnimationFrame(draw);
    return () => { if(animRef.current) cancelAnimationFrame(animRef.current); };
  }, [simRunning, tab, getSignalState]);

  const startSim = () => { simTimeRef.current=0; simCarsRef.current=[]; simCarId.current=0; spawnTimersRef.current={}; simPedsRef.current=[]; simPedId.current=0; pedSpawnTimersRef.current={}; setSimTime(0); setSimRunning(true); };
  const stopSim = () => { setSimRunning(false); if(animRef.current) cancelAnimationFrame(animRef.current); };

  // ═══════════════════════════════════════════════════════════════
  const tabs_ = [
    { id:"converter", label:"📝 DB작성", accent:"#22d3ee" },
    { id:"signalmap", label:"📡 시그널맵", accent:"#a78bfa" },
    { id:"dayplan", label:"📅 DAY PLAN", accent:"#f472b6" },
    { id:"simulation", label:"🚦 시뮬레이션", accent:"#f59e0b" },
    { id:"validate", label:"✅ 검증", accent:"#34d399" },
  ];

  // 교차로 다이어그램 LSU 박스
  const LsuBox = ({pos, style:extraStyle}) => {
    const cfg = lsuConfig.find(c=>c.pos===pos);
    if (!cfg) return <div/>;
    const ped = cfg.type==="보행";
    const active = editIdx>=0 && phases[editIdx]?.lsus?.[cfg.lsu];
    const move = active || "";
    return (
      <div onClick={()=>editIdx>=0 && handleLsuClick(cfg.lsu)}
        style={{ width:ped?50:56, height:ped?26:32, borderRadius:4, cursor:editIdx>=0?"pointer":"default",
          background:active?(ped?"#f472b6":"#22c55e"):"#1e293b",
          border:`2px solid ${active?(ped?"#f472b6":"#22c55e"):"#334155"}`,
          display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center", transition:"all 0.15s", ...extraStyle }}>
        <div style={{fontSize:10,fontWeight:800,color:active?"#fff":(ped?"#f472b6":"#94a3b8")}}>LSU{cfg.lsu}</div>
        {active && move!=="보행" && <div style={{fontSize:9,color:"#fff",fontWeight:600}}>{move}</div>}
      </div>
    );
  };

  return (
    <div style={{background:"#0f0f1a",minHeight:"100vh",color:"#e2e8f0",fontFamily:"'Pretendard','Noto Sans KR',-apple-system,sans-serif"}}>
      {/* Header */}
      <div style={{background:"linear-gradient(135deg,#1a1a2e,#16213e)",borderBottom:"1px solid #2a2a4a",padding:"12px 24px",display:"flex",alignItems:"center",justifyContent:"space-between"}}>
        <div style={{display:"flex",alignItems:"center",gap:16}}>
          <div style={{width:36,height:36,borderRadius:8,background:"linear-gradient(135deg,#06b6d4,#8b5cf6)",display:"flex",alignItems:"center",justifyContent:"center",fontWeight:900,fontSize:14,color:"#fff"}}>T</div>
          <div><div style={{fontWeight:800,fontSize:16}}>탑아이티 <span style={{color:"#06b6d4"}}>Signal DB Tool</span></div><div style={{fontSize:11,color:"#64748b"}}>교통신호제어기 DB 관리 · 서돌전자용</div></div>
        </div>
        <div style={{display:"flex",gap:8,alignItems:"center"}}>
          <input type="file" ref={fileRef} accept=".dat" onChange={handleFileOpen} style={{display:"none"}} />
          <button onClick={()=>fileRef.current?.click()} style={{...btnStyle,background:"#1e293b",border:"1px solid #334155"}}>📂 열기</button>
          <button onClick={handleSave} style={{...btnStyle,background:"linear-gradient(135deg,#06b6d4,#8b5cf6)",fontWeight:700}}>💾 저장</button>
          <button onClick={exportExcel} style={{...btnStyle,background:"linear-gradient(135deg,#10b981,#059669)",fontWeight:700}}>📊 주기표</button>
          <div style={{fontSize:11,color:"#64748b",maxWidth:200,overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}}>{statusMsg}</div>
        </div>
      </div>
      <div style={{display:"flex",background:"#13132a",borderBottom:"1px solid #1e1e3a",padding:"0 16px"}}>
        {tabs_.map(t=><button key={t.id} onClick={()=>setTab(t.id)} style={{padding:"10px 20px",fontSize:13,fontWeight:tab===t.id?700:400,color:tab===t.id?t.accent:"#94a3b8",background:"transparent",border:"none",cursor:"pointer",borderBottom:tab===t.id?`2px solid ${t.accent}`:"2px solid transparent"}}>{t.label}</button>)}
      </div>

      <div style={{padding:20,maxWidth:1400,margin:"0 auto"}}>
        {/* ══════ 컨버터 ══════ */}
        {tab==="converter" && (
          <div style={{display:"flex",gap:16}}>
            {/* 왼쪽 */}
            <div style={{width:340,display:"flex",flexDirection:"column",gap:12,flexShrink:0}}>
              <div style={{...cardStyle,display:"flex",gap:8,alignItems:"center"}}>
                <input value={convName} onChange={e=>setConvName(e.target.value)} placeholder="교차로 이름" style={{...inputStyle,flex:1}} />
                <button onClick={loadExample} style={{...btnStyle,fontSize:11,background:"#1e293b",border:"1px solid #334155"}}>예제</button>
              </div>

              {/* 교차로 다이어그램 */}
              <div style={{...cardStyle,display:"flex",flexDirection:"column",alignItems:"center",padding:"16px 8px"}}>
                <div style={{fontSize:12,color:"#64748b",marginBottom:8}}>
                  {editIdx>=0 ? `${editIdx+1}현시 편집 — LSU 클릭` : "아래 현시를 선택하세요"}
                </div>
                <div style={{display:"grid",gridTemplateColumns:"56px 56px 80px 56px 56px",gridTemplateRows:"34px 30px 40px 40px 30px 34px",gap:2,justifyItems:"center",alignItems:"center",position:"relative"}}>
                  {/* Row 1: 북 차량 */}
                  <div/><div/><LsuBox pos="top"/><div/><div/>
                  {/* Row 2: 북 보행 */}
                  <div/><div/><LsuBox pos="top-ped"/><div/><div/>
                  {/* Row 3-4: 서차량, 서보행, 교차로, 동보행, 동차량 (세로 중앙 정렬) */}
                  <LsuBox pos="left" style={{gridRow:"3/5",alignSelf:"center"}}/><LsuBox pos="left-ped" style={{gridRow:"3/5",alignSelf:"center"}}/>
                  <div style={{background:"#1a1a30",border:"1px solid #2a2a4a",borderRadius:4,width:76,height:76,display:"flex",alignItems:"center",justifyContent:"center",gridColumn:"3",gridRow:"3/5",fontSize:10,color:"#374151"}}>교차로</div>
                  <LsuBox pos="right-ped" style={{gridRow:"3/5",alignSelf:"center"}}/><LsuBox pos="right" style={{gridRow:"3/5",alignSelf:"center"}}/>
                  {/* Row 5: 남 보행 */}
                  <div/><div/><LsuBox pos="bottom-ped"/><div/><div/>
                  {/* Row 6: 남 차량 */}
                  <div/><div/><LsuBox pos="bottom"/><div/><div/>
                </div>
                <div style={{fontSize:10,color:"#4a5568",marginTop:6}}>차량 클릭 = 이동류 선택 | 보행 클릭 = 토글</div>

                {/* 차량 LSU 체크박스 팝업 */}
                {lsuPopup && (() => {
                  const cfg = lsuConfig.find(c => c.lsu === lsuPopup.lsuNum);
                  return (
                    <div style={{marginTop:8,background:"#1e293b",border:"1px solid #06b6d4",borderRadius:8,padding:"12px 16px",width:"100%"}}>
                      <div style={{fontSize:13,fontWeight:700,color:"#06b6d4",marginBottom:8}}>
                        LSU{lsuPopup.lsuNum} ({cfg?.dir}) 이동류 선택
                      </div>
                      <div style={{display:"flex",gap:12,marginBottom:10}}>
                        <label style={{display:"flex",alignItems:"center",gap:6,cursor:"pointer",fontSize:13,color:"#e2e8f0"}}>
                          <input type="checkbox" checked={lsuPopup.straight}
                            onChange={e => setLsuPopup({...lsuPopup, straight: e.target.checked})}
                            style={{width:18,height:18,accentColor:"#22c55e",cursor:"pointer"}} />
                          직진 <span style={{fontSize:11,color:"#94a3b8"}}>(A링 0x10)</span>
                        </label>
                        <label style={{display:"flex",alignItems:"center",gap:6,cursor:"pointer",fontSize:13,color:"#e2e8f0"}}>
                          <input type="checkbox" checked={lsuPopup.left}
                            onChange={e => setLsuPopup({...lsuPopup, left: e.target.checked})}
                            style={{width:18,height:18,accentColor:"#16a34a",cursor:"pointer"}} />
                          좌회전 <span style={{fontSize:11,color:"#94a3b8"}}>(B링 0x01)</span>
                        </label>
                      </div>
                      <div style={{display:"flex",gap:8}}>
                        <button onClick={applyLsuPopup} style={{...btnStyle,background:"#06b6d4",color:"#000",fontWeight:700,fontSize:12,padding:"5px 16px"}}>적용</button>
                        <button onClick={()=>setLsuPopup(null)} style={{...btnStyle,background:"#334155",fontSize:12,padding:"5px 12px"}}>취소</button>
                        {(lsuPopup.straight || lsuPopup.left) && (
                          <button onClick={()=>{setLsuPopup({...lsuPopup,straight:false,left:false})}} style={{...btnStyle,background:"none",border:"1px solid #ef4444",color:"#ef4444",fontSize:12,padding:"5px 12px"}}>해제</button>
                        )}
                      </div>
                    </div>
                  );
                })()}
              </div>

              {/* 현시 목록 */}
              <div style={cardStyle}>
                <div style={{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:8}}>
                  <h3 style={sectionTitle}>현시 목록</h3>
                  <button onClick={addPhase} style={{...btnStyle,fontSize:11,padding:"4px 12px",background:"#1e293b"}}>+ 추가</button>
                </div>
                {phases.length===0 && <div style={{color:"#4a5568",fontSize:12,textAlign:"center",padding:16}}>현시를 추가하세요</div>}
                {phases.map((p,i)=>(
                  <div key={i} onClick={()=>{setEditIdx(i);setLsuPopup(null);}} style={{padding:"8px 12px",marginBottom:4,borderRadius:6,cursor:"pointer",display:"flex",alignItems:"center",gap:8,
                    background:editIdx===i?"#06b6d420":"#0f0f1a",border:`1px solid ${editIdx===i?"#06b6d4":"#1e1e3a"}`}}>
                    <span style={{color:"#06b6d4",fontWeight:800,fontSize:14,width:24}}>{i+1}</span>
                    <div style={{flex:1}}>
                      <div style={{fontSize:13,fontWeight:600}}>{getDesc(p)}</div>
                      <div style={{fontSize:11,color:"#64748b"}}>{isPed(p)?`대기:${p.pedWait||1} PG:${p.pedGreen} PF:${p.pedFlash}`:""} {isPed(p)?"4+EOP":"2+EOP"}</div>
                    </div>
                    <div style={{width:80,height:34,flexShrink:0}}><PhaseArrowsSvg phase={p} lsuConfig={lsuConfig}/></div>
                    <button onClick={e=>{e.stopPropagation();removePhase(i);}} style={{background:"none",border:"none",color:"#ef4444",cursor:"pointer",fontSize:16}}>×</button>
                  </div>
                ))}
              </div>
              <button onClick={runConversion} style={{...btnStyle,width:"100%",padding:"14px",background:"linear-gradient(135deg,#06b6d4,#8b5cf6)",fontSize:15,fontWeight:900,letterSpacing:1}}>★ 시그널맵 맵핑 실행</button>
            </div>

            {/* 오른쪽 */}
            <div style={{flex:1,display:"flex",flexDirection:"column",gap:12}}>
              {editIdx>=0 && editIdx<phases.length && (()=>{
                const ph=phases[editIdx]; const ped=isPed(ph);
                const actives=Object.entries(ph.lsus||{}).map(([n,m])=>{const c=lsuConfig.find(x=>x.lsu===Number(n)); return {num:Number(n),move:m,dir:c?.dir,type:c?.type};});
                return (
                  <div style={cardStyle}>
                    <h3 style={sectionTitle}>{editIdx+1}현시 — {getDesc(ph)}</h3>
                    <div style={{display:"flex",gap:6,flexWrap:"wrap",marginTop:8,marginBottom:12}}>
                      {actives.length===0 && <span style={{color:"#4a5568",fontSize:12}}>교차로 그림에서 LSU를 클릭하세요</span>}
                      {actives.map(l=>(
                        <div key={l.num} style={{padding:"4px 10px",borderRadius:20,fontSize:12,fontWeight:700,
                          background:l.type==="보행"?"#f472b620":"#22c55e20",color:l.type==="보행"?"#f472b6":"#22c55e",
                          border:`1px solid ${l.type==="보행"?"#f472b6":"#22c55e"}`}}>
                          LSU{l.num} {l.dir} {l.move}
                        </div>
                      ))}
                    </div>
                    <div style={{display:"grid",gridTemplateColumns:ped?"1fr 1fr 1fr 1fr":"1fr",gap:8}}>
                      {ped && <div><label style={labelSmall}>보행대기</label><input type="number" value={ph.pedWait||""} onChange={e=>updatePF(editIdx,"pedWait",e.target.value)} style={{...inputStyle,width:"100%",marginTop:4}}/></div>}
                      {ped && <div><label style={labelSmall}>보행녹색</label><input type="number" value={ph.pedGreen||""} onChange={e=>updatePF(editIdx,"pedGreen",e.target.value)} style={{...inputStyle,width:"100%",marginTop:4}}/></div>}
                      {ped && <div><label style={labelSmall}>보행점멸</label><input type="number" value={ph.pedFlash||""} onChange={e=>updatePF(editIdx,"pedFlash",e.target.value)} style={{...inputStyle,width:"100%",marginTop:4}}/></div>}
                      <div><label style={labelSmall}>황색</label><input type="number" value={ph.yellow||""} onChange={e=>updatePF(editIdx,"yellow",e.target.value)} style={{...inputStyle,width:"100%",marginTop:4}}/></div>
                    </div>
                    <div style={{marginTop:12,padding:10,background:"#0f0f1a",borderRadius:6,fontSize:12,color:"#94a3b8"}}>
                      <strong style={{color:"#e2e8f0"}}>생성될 스텝:</strong>
                      {ped ? <div style={{marginTop:4}}>1: 차량G(MIN={ph.pedWait||"?"}) → 2: +보행G(MIN={ph.pedGreen||"?"}) → 3: +보행GF(MIN={ph.pedFlash||"?"}) → 4: 차량G(<span style={{color:"#22d3ee"}}>MAX=현시값×1.5</span>) → <span style={{color:"#eab308"}}>EOP({ph.yellow||3}s)</span></div>
                        : <div style={{marginTop:4}}>1: 차량G(MIN=15) → 2: 차량G(<span style={{color:"#22d3ee"}}>MAX=현시값×1.5</span>) → <span style={{color:"#eab308"}}>EOP({ph.yellow||3}s)</span></div>}
                    </div>
                  </div>
                );
              })()}

              <div style={cardStyle}>
                <div style={{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:12}}>
                  <h3 style={sectionTitle}>▼ 시간대별 타이밍</h3>
                  <button onClick={addPeriod} style={{...btnStyle,fontSize:11,padding:"4px 12px",background:"#1e293b"}}>+ 시간대</button>
                </div>
                <div style={{overflowX:"auto"}}>
                  <table style={tableStyle}>
                    <thead><tr>{["시작","주기","옵셋",...Array.from({length:8},(_,i)=>`${i+1}현시`)].map((h,i)=><th key={i} style={thStyle}>{h}</th>)}</tr></thead>
                    <tbody>{periods.map((p,i)=>(
                      <tr key={i}>
                        <td style={tdStyle}><input value={p.time} onChange={e=>updatePeriod(i,"time",e.target.value)} style={{...cellInput,width:60}}/></td>
                        <td style={tdStyle}><input type="number" value={p.ph.reduce((a,b)=>a+b,0)||""} readOnly style={{...cellInput,width:50,background:"#12122a",color:"#22d3ee",fontWeight:700,cursor:"default"}}/></td>
                        <td style={tdStyle}><input type="number" value={p.offset!=null?p.offset:""} onChange={e=>updatePeriod(i,"offset",e.target.value)} style={{...cellInput,width:50}}/></td>
                        {p.ph.map((v,j)=><td key={j} style={tdStyle}><input type="number" value={v||""} onChange={e=>updatePeriod(i,`ph${j}`,e.target.value)} style={{...cellInput,width:42}}/></td>)}
                      </tr>
                    ))}</tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* ══════ 시그널맵 ══════ */}
        {tab==="signalmap" && (
          <div>
            <div style={{display:"flex",gap:6,flexWrap:"wrap",marginBottom:6,justifyContent:"center"}}>
              {Object.entries(STEP_CODES).filter(([k])=>[0,1,2,5,16,32].includes(Number(k))).map(([code,info])=>(
                <div key={code} style={{display:"flex",alignItems:"center",gap:4,fontSize:11}}>
                  <div style={{width:18,height:18,borderRadius:3,background:info.color,display:"flex",alignItems:"center",justifyContent:"center",color:info.text,fontSize:9,fontWeight:700}}>{info.short}</div>
                  <span style={{color:"#94a3b8"}}>{info.label}</span>
                </div>
              ))}
            </div>
            <div style={{textAlign:"center",fontSize:11,color:"#64748b",marginBottom:12}}>컨버터에서 생성 · .dat에서 로드</div>
            {(()=>{
              const sA=datData?.ringA, sB=datData?.ringB;
              if(!sA&&!sB) return <div style={{...cardStyle,color:"#64748b",textAlign:"center",padding:40}}>데이터 없음</div>;
              const Ring=({label,accent,steps})=>(
                <div style={{flex:1,minWidth:0}}>
                  <div style={{padding:"8px 12px",background:accent+"15",borderBottom:`2px solid ${accent}`,borderRadius:"8px 8px 0 0",display:"flex",alignItems:"center",gap:8}}>
                    <div style={{width:8,height:8,borderRadius:"50%",background:accent}}/><span style={{fontWeight:800,fontSize:13,color:accent}}>{label}</span>
                  </div>
                  <div style={{overflowX:"auto"}}>
                    <table style={{borderCollapse:"collapse",width:"100%"}}>
                      <thead>
                        <tr style={{background:"#111122"}}><th rowSpan={2} style={{...mapThStyle,width:36,fontSize:10,verticalAlign:"middle"}}>#</th><th colSpan={16} style={{...mapThStyle,fontSize:11,padding:"4px 2px",borderBottom:"none",letterSpacing:2}}>LSU</th><th colSpan={3} style={{...mapThStyle,fontSize:11,padding:"4px 2px",borderBottom:"none",borderLeft:"1px solid #2a2a4a"}}>시간설정</th></tr>
                        <tr style={{background:"#111122"}}>{Array.from({length:16},(_,l)=><th key={l} style={{...mapThStyle,fontSize:10,padding:"4px 2px"}}>{l+1}</th>)}<th style={{...mapThStyle,width:32,fontSize:10,borderLeft:"1px solid #2a2a4a"}}>MIN</th><th style={{...mapThStyle,width:32,fontSize:10}}>MAX</th><th style={{...mapThStyle,width:28,fontSize:10}}>EOP</th></tr>
                      </thead>
                      <tbody>{steps && Array.from({length:32},(_,i)=>{
                        const s=steps[i]||{lsu:new Uint8Array(16),min:0,max:0,eop:0}; const isEop=s.eop===1;
                        return (<tr key={i} style={{background:isEop?"#eab30830":"transparent"}}>
                          <td style={{...mapTdStyle,fontWeight:700,color:isEop?"#eab308":"#4a5568",fontSize:10,padding:"1px 3px"}}>{i+1}</td>
                          {Array.from({length:16},(_,l)=>(<td key={l} style={{padding:0,width:38,height:32,borderBottom:isEop?"2px solid #eab30855":"1px solid #1e1e30",background:isEop&&!s.lsu[l]?"#eab30820":"transparent"}}><CodeCell code={s.lsu[l]}/></td>))}
                          <td style={{...mapTdStyle,fontFamily:"monospace",color:"#e2e8f0",fontSize:11,padding:"1px 2px",background:isEop?"#eab30820":"transparent"}}>{s.min||""}</td>
                          <td style={{...mapTdStyle,fontFamily:"monospace",color:"#e2e8f0",fontSize:11,padding:"1px 2px",background:isEop?"#eab30820":"transparent"}}>{s.max||""}</td>
                          <td style={{...mapTdStyle,textAlign:"center",padding:"1px 2px",background:isEop?"#eab30820":"transparent"}}>{isEop?<span style={{color:"#eab308",fontWeight:900,fontSize:12}}>◆</span>:""}</td>
                        </tr>);
                      })}</tbody>
                    </table>
                  </div>
                </div>
              );
              return (<div style={{display:"flex",gap:12}}>
                <div style={{...cardStyle,flex:1,padding:0,overflow:"hidden"}}><Ring label="일반제-(A) 직진/보행" accent="#22d3ee" steps={sA}/></div>
                <div style={{...cardStyle,flex:1,padding:0,overflow:"hidden"}}><Ring label="일반제-(B) 좌회전" accent="#a78bfa" steps={sB}/></div>
              </div>);
            })()}
          </div>
        )}

        {/* ══════ DAY PLAN ══════ */}
        {tab==="dayplan" && (
          <div>
            <div style={{display:"flex",gap:12,marginBottom:16,alignItems:"center"}}>
              <label style={labelSmall}>플랜</label>
              <select value={viewPlan} onChange={e=>setViewPlan(Number(e.target.value))} style={{...inputStyle,width:200}}>
                {Array.from({length:5},(_,i)=><option key={i} value={i}>일반제 플랜 {i+1}</option>)}
                {Array.from({length:5},(_,i)=><option key={i+5} value={i+5}>시차제 플랜 {i+1}</option>)}
              </select>
            </div>
            <div style={{...cardStyle,overflowX:"auto"}}>
              {datData?.dayPlans?.[viewPlan] ? (
                <table style={tableStyle}>
                  <thead><tr><th style={thStyle}>수준</th><th style={thStyle}>시작</th><th style={thStyle}>주기</th><th style={thStyle}>옵셋</th>{Array.from({length:8},(_,i)=><th key={i} style={thStyle}>{i+1}현시</th>)}</tr></thead>
                  <tbody>{datData.dayPlans[viewPlan].map((e,i)=>e.cycle>0&&(<tr key={i}><td style={tdStyle}><span style={{color:"#06b6d4",fontWeight:700}}>수준{i+1}</span></td><td style={tdStyle}>{String(e.hour).padStart(2,"0")}:{String(e.min).padStart(2,"0")}</td><td style={{...tdStyle,fontWeight:700,color:"#e2e8f0"}}>{e.cycle}</td><td style={tdStyle}>{e.offset}</td>{e.splits.map(([a],j)=><td key={j} style={{...tdStyle,color:a>0?"#e2e8f0":"#374151"}}>{a||""}</td>)}</tr>))}</tbody>
                </table>
              ) : <div style={{color:"#64748b",textAlign:"center",padding:40}}>데이터 없음</div>}
            </div>
          </div>
        )}

        {/* ══════ 시뮬레이션 ══════ */}
        {tab==="simulation" && (
          <div style={{display:"flex",flexDirection:"column",gap:16}}>
            {/* 컨트롤 바 */}
            <div style={{...cardStyle,display:"flex",alignItems:"center",gap:16,flexWrap:"wrap"}}>
              {!simRunning ? (
                <button onClick={()=>{if(phases.length===0||periods.length===0){alert("현시와 타이밍을 먼저 정의하세요");return;}startSim();}} style={{...btnStyle,background:"linear-gradient(135deg,#f59e0b,#ef4444)",fontWeight:800,fontSize:14,padding:"10px 28px"}}>▶ 시뮬레이션 시작</button>
              ) : (
                <button onClick={stopSim} style={{...btnStyle,background:"#ef4444",fontWeight:700,padding:"10px 28px"}}>⏹ 정지</button>
              )}
              <div style={{display:"flex",alignItems:"center",gap:8}}>
                <span style={{fontSize:12,color:"#94a3b8"}}>배속:</span>
                {[1,2,4].map(s=><button key={s} onClick={()=>{setSimSpeed(s);simSpeedRef.current=s;}} style={{...btnStyle,padding:"4px 12px",fontSize:12,background:simSpeed===s?"#f59e0b":"#1e293b",color:simSpeed===s?"#000":"#94a3b8",fontWeight:simSpeed===s?800:400}}>×{s}</button>)}
              </div>
              <div style={{display:"flex",alignItems:"center",gap:8}}>
                <span style={{fontSize:12,color:"#94a3b8"}}>밀도:</span>
                <input type="range" min={1} max={5} value={simDensity} onChange={e=>{setSimDensity(Number(e.target.value));simDensityRef.current=Number(e.target.value);}} style={{width:80,accentColor:"#22c55e"}} />
                <span style={{fontSize:11,color:"#22c55e",fontWeight:600}}>{["","한산","여유","보통","혼잡","정체"][simDensity]}</span>
              </div>
              <div style={{display:"flex",alignItems:"center",gap:8}}>
                <span style={{fontSize:12,color:"#94a3b8"}}>시간대:</span>
                <select value={simPeriodIdx} onChange={e=>{setSimPeriodIdx(Number(e.target.value));simPeriodRef.current=Number(e.target.value);}} style={{...inputStyle,padding:"4px 8px",fontSize:12}}>
                  {periods.map((p,i)=><option key={i} value={i}>수준{i+1} ({p.time})</option>)}
                </select>
              </div>
              <div style={{marginLeft:"auto",fontSize:12,color:"#64748b"}}>
                경과: <strong style={{color:"#e2e8f0"}}>{Math.floor(simTime)}초</strong>
              </div>
            </div>

            {/* Canvas */}
            <div style={{...cardStyle,display:"flex",justifyContent:"center",padding:16}}>
              <canvas ref={canvasRef} width={SIM_W} height={SIM_H} style={{borderRadius:10,border:"1px solid #1e293b",maxWidth:"100%",height:"auto"}} />
            </div>

            {/* 범례 */}
            <div style={{...cardStyle,display:"flex",gap:20,flexWrap:"wrap",alignItems:"center"}}>
              <span style={{fontSize:11,color:"#64748b",fontWeight:600}}>방향별 차량색:</span>
              {[["북(N)","#3B82F6"],["남(S)","#8B5CF6"],["동(E)","#F59E0B"],["서(W)","#10B981"]].map(([l,c])=>(
                <div key={l} style={{display:"flex",alignItems:"center",gap:4,fontSize:11}}>
                  <div style={{width:14,height:8,borderRadius:2,background:c}} />
                  <span style={{color:"#94a3b8"}}>{l}</span>
                </div>
              ))}
            </div>
          </div>
        )}


        {/* ══════ 검증 ══════ */}
        {tab==="validate" && (
          <div style={{display:"flex",flexDirection:"column",gap:16}}>
            {datData ? (<>
              <div style={cardStyle}>
                <h3 style={sectionTitle}>검증 결과</h3>
                {(()=>{const errors=[]; const eA=datData.ringA?.filter(s=>s.eop).length||0, eB=datData.ringB?.filter(s=>s.eop).length||0;
                  if(!eA) errors.push("Ring A: EOP 없음"); if(!eB) errors.push("Ring B: EOP 없음"); if(eA&&eB&&eA!==eB) errors.push(`Ring A(${eA})≠B(${eB})`);
                  return (<div style={{lineHeight:2}}><div>현시: <strong>{eA}</strong>(A) / <strong>{eB}</strong>(B)</div><div>스텝: <strong>{datData.ringA?.filter(s=>s.min>0||s.eop).length||0}</strong></div>
                    {datData.mfr?.name&&<div>제조사: <strong>{datData.mfr.name}</strong></div>}
                    <div style={{marginTop:12}}>{errors.length===0?<span style={{color:"#34d399",fontWeight:700}}>✅ 통과</span>:<div><span style={{color:"#ef4444",fontWeight:700}}>❌ 오류:</span>{errors.map((e,i)=><div key={i} style={{color:"#fca5a5",marginLeft:16}}>• {e}</div>)}</div>}</div></div>);
                })()}
              </div>
              <div style={cardStyle}>
                <h3 style={sectionTitle}>LSU 정보</h3>
                <div style={{display:"grid",gridTemplateColumns:"repeat(4,1fr)",gap:8}}>
                  {datData.lsuTypes?.map((t,i)=>(<div key={i} style={{background:t.t1>0?"#1e293b":"#0f172a",border:`1px solid ${t.t1>0?"#334155":"#1e293b"}`,borderRadius:8,padding:"10px 12px",textAlign:"center"}}>
                    <div style={{fontSize:12,fontWeight:700,color:t.t1>0?"#e2e8f0":"#374151"}}>LSU{i+1}</div>
                    <div style={{fontSize:11,color:"#94a3b8"}}>{LSU_TYPES_MAP[t.t1]||(t.t1?`0x${t.t1.toString(16)}`:"—")}</div>
                    {i<8&&<div style={{fontSize:10,color:datData.lsuActive[i]?"#34d399":"#374151"}}>{datData.lsuActive[i]?"● 활성":"○ 비활성"}</div>}
                  </div>))}
                </div>
              </div>
            </>) : <div style={{...cardStyle,color:"#64748b",textAlign:"center",padding:60}}>데이터 없음</div>}
          </div>
        )}
      </div>
    </div>
  );
}

const btnStyle={border:"none",borderRadius:6,padding:"7px 16px",fontSize:13,color:"#e2e8f0",cursor:"pointer",transition:"all 0.15s"};
const cardStyle={background:"#161625",border:"1px solid #2a2a4a",borderRadius:10,padding:16};
const sectionTitle={fontSize:14,fontWeight:700,color:"#e2e8f0",margin:"0 0 4px"};
const labelSmall={fontSize:12,color:"#94a3b8",fontWeight:600};
const inputStyle={background:"#1e1e35",border:"1px solid #333358",borderRadius:6,padding:"6px 10px",color:"#e2e8f0",fontSize:13,outline:"none"};
const cellInput={background:"#1a1a30",border:"1px solid #2a2a4a",borderRadius:4,padding:"4px 6px",color:"#e2e8f0",fontSize:12,outline:"none",textAlign:"center"};
const tableStyle={borderCollapse:"collapse",width:"100%",fontSize:13};
const thStyle={padding:"8px 6px",textAlign:"center",color:"#94a3b8",fontWeight:700,fontSize:12,borderBottom:"2px solid #2a2a4a",whiteSpace:"nowrap"};
const tdStyle={padding:"4px 6px",textAlign:"center",borderBottom:"1px solid #1e1e30",color:"#cbd5e1"};
const mapThStyle={padding:"8px 4px",textAlign:"center",color:"#94a3b8",fontWeight:700,fontSize:11,borderBottom:"2px solid #2a2a4a",whiteSpace:"nowrap"};
const mapTdStyle={padding:"2px 4px",textAlign:"center",borderBottom:"1px solid #1e1e30",fontSize:12};
